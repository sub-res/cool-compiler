# SPIM S20 MIPS simulator.
#
# Modified trap handler for COOL runtime.
#
# 12/13/99 Steven J Kowal  (added Arrays)
# 2/01/95 Carleton Miyamoto
# 8/19/94 Manuel Fahndrich
#
# $Log: cool-runtime.s,v $
# Revision 7.7  2015/01/12 20:49:12  boyland
# Added coe for native class constructors.
#
# Revision 7.6  2013/01/15 01:39:13  boyland
# Make more like standard Scala collections.
#
# Revision 7.5  2012/01/04 15:41:34  boyland
# Cool 2011
#
# Revision 7.4  2010/11/05 19:52:13  boyland
# Added statistics.
#
# Revision 7.3  2010/01/05 21:26:00  boyland
# AVoid crashing if IO.out is passed null.
#
# Revision 7.2  2009/01/29 03:45:49  boyland
# Cool runtime
#
# Revision 7.1  2008/01/21 22:26:13  boyland
# Cool 2006.
#
# Revision 7.0  2006/01/19 15:19:20  boyland
# COOL 2005 final
#
# Revision 6.5  2005/01/19 17:56:20  boyland
# Cool 2004 with single-executable architecture complete.
# CS 754 changes complete.
#
# Revision 6.1  2005/01/19 17:53:17  boyland
# Remove un-needed calls to constructors.  This avoids
# problems with 0-cfa optimization.
#
# Revision 6.0  2004/08/14 16:05:11  boyland
# COOL 2004 (complete)
#
# Revision 5.0  2003/12/31 17:58:53  boyland
# Spring 2003 completed
#
# Revision 4.1  2003/01/10 23:07:51  boyland
# Fixed for modern SPIM.
#
# Revision 4.0  2002/12/02 04:32:18  boyland
# COOL 2002 final version
#
# Revision 3.1  2002/12/02 04:29:52  boyland
# Better errors on case aborts.
#
# Revision 3.0  2002/01/11 16:53:15  boyland
# COOL 2001.
# Preparing for COOL 2002.
#
# Revision 2.3  2002/01/11 16:52:01  boyland
# abort on missing case now gives line number and filename as well.
# (COOL 2001 - late addition)
#
# Revision 2.2  2001/05/01 16:01:20  boyland
# bug in String_equals.
#
# Revision 2.1  2001/01/25 16:20:27  boyland
# Cool 2001.
#
# Revision 2.0  2001/01/03 22:32:41  boyland
# Spring 2000 version
#
# Revision 1.6  2000/01/18 16:26:14  boyland
# Rewrote Arry.resize drastically.
#
# Revision 1.5  2000/01/18 15:26:26  boyland
# Made Array.set_size GC compliant.
#
# Revision 1.4  2000/01/18 14:26:22  boyland
# Changed to use constructors instead of _init routines.
#
# Revision 1.3  2000/01/10 16:13:50  boyland
# Added Array
#
# Revision 1.2  1999/07/24 22:38:54  boyland
# Updated for CS654 Spring 1999.
#
# Revision 1.1  1998/12/18 22:08:37  boyland
# Initial revision
#
# Revision 1.1.1.1.4.1  1996/09/17 08:21:39  aiken
# new Makefile, new results
#
#
#
# - updated instructions
# - cleanup of Makefile + new parameters
# - new VERSION file
#
# cleanup of Makefile; removed -static
#
# fixed a bug in PA2 assignment skeleton
#
# paramaterization
#
# updated skeletons to pass ostreams by ref
# paramaterized makefile
#
#
# pass ostreams by ref in SKEL
# parameterized Makefile
#
# new parameters
#
# new parameters
#
# just copied, not actually updated
#
# Revision 1.1.1.1  1996/07/12 06:48:08  aiken
# Imported sources
#
# Revision 2.3  1996/05/31 17:55:22  aiken
# added copyright notice
#
# Revision 2.2  1996/05/28 22:02:38  aiken
# fixed spelling errors,
# brought comments up to date
#
# Revision 2.1  1995/11/08 01:14:41  dgay
# Add a _MemMgr_Test function that calls the garbage collector if the
# global _MemMgr_TEST is non-zero (this global is generated by coolc
# when the -t option is used).
# _MemMgr_Test is called on every memory allocation, i.e. in Object.copy,
# String.concat, String.substr, IO.in_string, IO.in_int
#
# Revision 2.0  1995/09/26 01:26:13  dgay
# - Merged changes between revisions 1.12 and 1.13 of trap handler into
#   trap handler for GC from miyamoto.
# - Fixed bug in generational GC: didn't handle assignments properly
#   (registers were trashed)
# - Changed method of identifying pointers on stack:
#   no tags pushed, simply checks that values are even and are in the
#   correct address range. Aborts if eyecatcher missing.
# - Added _gc_check primitive to check the presence of an eyecatcher
#   on an object.
# - Removed the Stop & Copy GC.
#
#   Revision 2.2  1995/05/17  20:15:41  miyamoto
#   - The "NoGC" garbage collector.  This collector does nothing but
#     expand the heap when more memory is required.
#   - support for multiple garbage collectors added.
#   - "_MemMgr_*" functions give an consistent view of the garbage
#     collectors.  It uses the addresses stored in "_MemMgr_INITIALIZER"
#     and "_MemMgr_COLLECTOR" to run the correct garbage collector.
#   - "_MemMgr_INITIALIZER" holds the address of the initialization
#     function for the garbage collector.  This is defined in the
#     program file (*.s).
#   - "_MemMgr_COLLECTOR" holds the address of the garbage collection
#     function.  This is defined in the program file (*.s).
#   - MemMgr_REG_MASK is used to determine which registers get auto-
#     updated.
#   - "_*GC_*Alloc" functions were removed.
#   - "*_REG_MASK" variables removed.
#
#   Revision 2.1  1995/03/13  15:58:32  miyamoto
#   - GenGC "Generational" garbage collector
#   - Converted all calls to "_SncGC_*" to their equivalent "_GenGC_*"
#   - Created constants:
#     GenGC_HDR*: Information in the GenGC header
#     GenGC_REG_MASK: Register mask for auto update
#     GenGC_ARU_MASK: All possible registers that can be auto updated
#     GenGC_HEAPEXPGRAN: Granularity of any heap expansion, heap is
#       always expanded in multiples of 2^GenGC_HEAPEXPGRAN
#     GenGC_OLDRATIO: Ratio of size of the old area to usable heap size
#   - Created GenGC error messages in the data seg (_GenGC_*)
#   - Object.copy: displays error message on an invalid object size
#
#   Revision 2.0  1995/02/16  17:32:38  miyamoto
#   - SncGC "Stop and Copy" garbage collector
#   - Created some constants:
#     obj_eyecatch: offset from object pointer to the eyecatcher
#     obj_disp: offset from object pointer to the dispatch table
#     obj_attr: offset from object pointer to the attributes
#     str_maxsize: the maximum length of a string
#     SncGC_REG_MASK: Register mask for auto update
#     SncGC_ARU_MASK: All possible registers that can be auto updated
#     SncGC_EXPANDSIZE: Size to expand heap when necessary (bytes)
#     SncGC_INFOSIZE: Size of SncGC header in the heap (bytes)
#   - Created some SncGC error messages in the data seg (_SncGC_*)
#   - Renamed labels in equality_test to contain a leading underscore
#     to avoid any conflicts which may arise
#   - Functions changed to accomodate SncGC:
#     __start: pushs Main object on the stack and calls "_SncGC_Init"
#     Object.copy: calls "_SncGC_Alloc" to allocate memory
#     IO.in_string, String.concat, String.substr:
#       uses "_SncGC_QAlloc" to verify allocation of memory
#   - Functions changed to accomodate stack flags:
#     Object.copy, IO.out_string, IO.out_int, IO.in_int, IO.in_string
#     String.concat, String.substr
#   - __start now sets $s0 to the self pointer of the Main object
#
#   *****
#   Warning (no changes made): String.substr trashes regs $t3 $t4
#   *****
#
#   Revision 1.12  1994/11/15  03:33:34  manuel
#   substr method didn't allow taking the empty substr at the end of a
#   string
#
#   Revision 1.11  1994/11/14  21:41:23  manuel
#   Comment for equality_test contained a type: arguments are in $t1 and
#   $t2
#
#   Revision 1.10  1994/10/26  02:31:50  manuel
#   Added more comments.
#
#   Revision 1.9  1994/08/31  02:04:31  manuel
#   Fixed an error in the in_string code: Reading from EOF, the system
#   returns 0 characters. We test for this and return a single '\n'. The
#   code can therefore recognize EOF.
#   The last line of a file must be terminated by a newline, otherwise
#   spim gets confused and returns the entire buffer!
#
#   Revision 1.8  1994/08/28  02:21:46  manuel
#   - Fixed typo in system message
#
#   Revision 1.7  1994/08/27  08:53:35  manuel
#   - Added an .align at end of data segment to be safe. Cgen should emit
#     one.
#
#   Revision 1.6  1994/08/27  08:37:49  manuel
#   - Added string primitives
#
#   Revision 1.5  1994/08/27  04:42:25  manuel
#   - Adapted code to handle String Class containing an Int object slot
#     for the string size.
#
#   Revision 1.4  1994/08/27  02:01:43  manuel
#   - Fixed typos
#
#   Revision 1.2  1994/08/27  00:41:01  manuel
#   - Changed string object representation to two slots. The first is a 32
#     bit slot indicating the string length, the second is a variable
#     sized slot containing the actual null terminated string.
#   - Fixed a bug in the in_string function which set obj_size to
#     4*obj_size
#   - Added constants for field offsets
#
#
# SPIM is distributed under the following conditions:
#
# You may make copies of SPIM for your own use and modify those copies.
#
# All copies of SPIM must retain my name and copyright notice.
#
# You may not sell SPIM or distributed SPIM in conjunction with a commerical
# product or service without the expressed written consent of James Larus.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE.
#
# Define the exception handling code.  This must go first!

	.kdata
__m1_:	.asciiz "  Exception "
__m2_:	.asciiz " occurred and ignored\n"
__m3_:	.asciiz	" occurred.  Abort.\n"
__e0_:	.asciiz "  [Interrupt] "
__e1_:	.asciiz	"  [TLB]"
__e2_:	.asciiz	"  [TLB]"
__e3_:	.asciiz	"  [TLB]"
__e4_:	.asciiz	"  [Address error in inst/data fetch] "
__e5_:	.asciiz	"  [Address error in store] "
__e6_:	.asciiz	"  [Bad instruction address] "
__e7_:	.asciiz	"  [Bad data address] "
__e8_:	.asciiz	"  [Error in syscall] "
__e9_:	.asciiz	"  [Break] "
__e10_:	.asciiz	"  [Reserved instruction] "
__e11_:	.asciiz	""
__e12_:	.asciiz	"  [Arithmetic overflow] "
__e13_:	.asciiz	"  [Trap] "
__e14_:	.asciiz	""
__e15_:	.asciiz	"  [Floating point] "
__e16_:	.asciiz	""
__e17_:	.asciiz	""
__e18_:	.asciiz	"  [Coproc 2]"
__e19_:	.asciiz	""
__e20_:	.asciiz	""
__e21_:	.asciiz	""
__e22_:	.asciiz	"  [MDMX]"
__e23_:	.asciiz	"  [Watch]"
__e24_:	.asciiz	"  [Machine check]"
__e25_:	.asciiz	""
__e26_:	.asciiz	""
__e27_:	.asciiz	""
__e28_:	.asciiz	""
__e29_:	.asciiz	""
__e30_:	.asciiz	"  [Cache]"
__e31_:	.asciiz	""
__excp:	.word __e0_, __e1_, __e2_, __e3_, __e4_, __e5_, __e6_, __e7_, __e8_, __e9_
	.word __e10_, __e11_, __e12_, __e13_, __e14_, __e15_, __e16_, __e17_, __e18_,
	.word __e19_, __e20_, __e21_, __e22_, __e23_, __e24_, __e25_, __e26_, __e27_,
	.word __e28_, __e29_, __e30_, __e31_
s1:	.word 0
s2:	.word 0

# This is the exception handler code that the processor runs when
# an exception occurs. It only prints some information about the
# exception, but can server as a model of how to write a handler.
#
# Because we are running in the kernel, we can use $k0/$k1 without
# saving their old values.

# This is the exception vector address for MIPS-1 (R2000):
#	.ktext 0x80000080
# This is the exception vector address for MIPS32:
	.ktext 0x80000180
# Select the appropriate one for the mode in which SPIM is compiled.
	.set noat
	move $k1 $at		# Save $at
	.set at
	sw $v0 s1		# Not re-entrant and we can't trust $sp
	sw $a0 s2		# But we need to use these registers

	mfc0 $k0 $13		# Cause register
	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f

	# Print information about exception.
	#
	li $v0 4		# syscall 4 (print_str)
	la $a0 __m1_
	syscall

	li $v0 1		# syscall 1 (print_int)
	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f
	syscall

	li $v0 4		# syscall 4 (print_str)
	andi $a0 $k0 0x3c
	lw $a0 __excp($a0)
	nop
	syscall

	bne $k0 0x18 ok_pc	# Bad PC exception requires special checks
	nop

	mfc0 $a0 $14		# EPC
	andi $a0 $a0 0x3	# Is EPC word-aligned?
	beq $a0 0 ok_pc
	nop

	li $v0 10		# Exit on really bad PC
	syscall

ok_pc:
	la $a0 __m3_
	li $v0 4
	syscall
        li $v0 10       # Exit upon all exceptions
        syscall         # syscall 10 (exit)

	li $v0 4		# syscall 4 (print_str)
	la $a0 __m2_
	syscall

	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f
	bne $a0 0 ret		# 0 means exception was an interrupt
	nop

# Interrupt-specific code goes here!
# Don't skip instruction at EPC since it has not executed.


ret:
# Return from (non-interrupt) exception. Skip offending instruction
# at EPC to avoid infinite loop.
#
	mfc0 $k0 $14		# Bump EPC register
	addiu $k0 $k0 4		# Skip faulting instruction
				# (Need to handle delayed branch case here)
	mtc0 $k0 $14


# Restore registers and reset procesor state
#
	lw $v0 s1		# Restore other registers
	lw $a0 s2

	.set noat
	move $at $k1		# Restore $at
	.set at

	mtc0 $0 $13		# Clear Cause register

	mfc0 $k0 $12		# Set Status register
	ori  $k0 0x1		# Interrupts enabled
	mtc0 $k0 $12

# Return from exception on MIPS32:
	eret

# Return sequence for MIPS-I (R2000):
#	rfe			# Return from exception handler
				# Should be in jr's delay slot
#	jr $k0
#	 nop


#
#  The code above this line is from spim.  Below this line are
#  the MIPS assembly routines implementing the Cool runtime system.
#  This code is Copyright (c) 1995,1996 The Regents of the University 
#  of California. All rights reserved.  See copyright.h for 
#  limitation of liability and disclaimer of warranty provisions.
#

#
# Functions that return to the cool caller, should preserve $s0-$s7
#
# $s7 is reserved as the limit pointer.
# $gp is the heap pointer (points to the next unused word)
#	should never be handled by the generated code!!!
# $sp is the stack pointer
# $ra contains the return address
#
# $v0, $v1, $t0, $t1, $t2, $a0, $a1, $a2 are scratch registers
#  (i.e. caller cannot assume that they remain unchanged)
#

	.data

_abort_msg:	.asciiz "Abort: "
_colon_msg:	.asciiz ":"
_dispatch_msg:  .asciiz ": Dispatch to null.\n"
_cabort_msg:	.asciiz ": No match in case statement for Class "
_dvabort_msg:	.asciiz ": Division overflow.\n"
_void_msg:	.asciiz "null"
_nl:		.asciiz "\n"
_term_msg:	.asciiz "COOL program successfully executed\n"
_sabort_msg1:	.asciiz	"Index to substring is negative\n"
_sabort_msg2:	.asciiz	"Index to substring is too big\n"
_sabort_msg3:	.asciiz	"Length to substring too long\n"
_sabort_msg4:	.asciiz	"Length to substring is negative\n"
_sabort_msg:	.asciiz "Execution aborted.\n"
_scharat_msg1:	.asciiz "Index to charAt is negative\n"
_scharat_msg2:	.asciiz "Index to charAt is too big\n"
_aabort_msg1:	.asciiz "Index to array is negative\n"
_aabort_msg2:   .asciiz "Index to array is too big\n"
_aabort_msg3:   .asciiz "Length to resize too large\n"
_aabort_msg4:   .asciiz "Length to resize is negative\n"
_aabort_msg:    .asciiz "Execution aborted.\n"
_ioabort_msg:	.asciiz "String for IO.out is null\n"
_csabort_msg:	.asciiz "String for IO.symbol is null\n"
_snabort_msg:	.asciiz "Symbol for IO.symbol_name is null\n"
_objcopy_msg:	.asciiz "Any.clone: Invalid object size.\n"
_gc_abort_msg:	.asciiz "GC bug!\n"

#
# Messages for the GenGC garabge collector
#

_GenGC_INITERROR:	.asciiz "GenGC: Unable to initialize the garbage collector.\n"
_GenGC_COLLECT:		.asciiz "Garbage collecting ...\n"
_GenGC_Major:		.asciiz "Major ...\n"
_GenGC_Minor:		.asciiz "Minor ...\n"
#_GenGC_COLLECT:		.asciiz ""
_GenGC_MINORERROR:	.asciiz "GenGC: Error during minor garbage collection.\n"
_GenGC_MAJORERROR:	.asciiz "GenGC: Error during major garbage collection.\n"

#
# Messages for the NoGC garabge collector
#

_NoGC_COLLECT:		.asciiz "Increasing heap...\n"
#_NoGC_COLLECT:		.asciiz ""

	.align 2

#
# Define some constants
#

obj_eyecatch=-4	# Unique id to verify any object
obj_tag=0
obj_size=4
obj_disp=8
obj_attr=12
int_slot=12
bool_slot=12
str_size=12	# This is a pointer to an Int object!!!
str_field=16	# The beginning of the ascii sequence
str_maxsize=1026	# the maximum string length
ary_size=12  	# This is a pointer to an Int object
ary_field=16    # The beginning of the array
sym_next=12	# next symbol
sym_name=16	# name (Cool string) of symbol
sym_hash=20	# hashcode (Cool int) of symbol

ary_header_words=4	# number of words in header

#
# The REG mask tells the garbage collector which register(s) it
# should automatically update on a garbage collection.  Note that
# this is (ANDed) with the ARU mask before the garbage collector
# reads it.  Only the registers specified in the garbage collector's
# ARU mask can be automatically updated.
#
# BITS----------------------------
# 3 2         1         0
# 10987654321098765432109876543210
# --------------------------------
#
# 00000000011111110000000000000000  <-  initial Register (REG) mask
# +--++--++--++--++--++--++--++--+      $s0-$s6
#    0   0   7   F   0   0   0   0     ($16-$22)
#

MemMgr_REG_MASK=0x007F0000

#
# Cool startup code.
# Create an object of type Main and then
# execute Main.Main with no arguments.
#
	.text
	.globl main
main:
	li	$v0 9
	move	$a0 $zero
	syscall				# sbrk
	move	$a0 $sp			# initialize the garbage collector
	li	$a1 MemMgr_REG_MASK
	move	$a2 $v0
	jal	_MemMgr_Init		# sets $gp and $s7 (limit)
	la	$a0 Main_protObj	# create the Main object
	jal	Any.clone		# Call copy
	addiu	$sp $sp -4
	sw	$a0 4($sp)		# save the Main object on the stack
	move	$s0 $a0			# set $s0 to point to self
	jal	Main.Main		# initialize the Main object

	addiu	$sp $sp 4		# restore the stack
	la	$a0 _term_msg		# show terminal message
	li	$v0 4
	syscall
	li $v0 10
	syscall				# syscall 10 (exit)

	.globl mainX
mainX:	jr	$ra

	
#
#  Polymorphic equality testing function:
#  Two objects are equal if they are
#    - identical (pointer equality, inlined in code)
#    - have same tag and are of type BOOL,STRING,INT and contain the
#      same data
#
#  INPUT: The two objects are passed in $t1 and $t2
#  OUTPUT: Initial value of $a0, if the objects are equal
#          Initial value of $a1, otherwise
#

	.globl	equality_test
equality_test:			# ops in $t1 $t2
				# true in A0, false in A1
				# assume $t1, $t2 are not equal
	beq	$t1 $zero _eq_false # $t2 can't also be void   
	beq     $t2 $zero _eq_false # $t1 can't also be void   
	lw	$v0 obj_tag($t1)	# get tags
	lw	$v1 obj_tag($t2)
	bne	$v1 $v0 _eq_false	# compare tags
	lw	$a2 Int_protObj	# load int tag
	beq	$v1 $a2 _eq_int	# Integers
	lw	$a2 Boolean_protObj	# load bool tag
	beq	$v1 $a2 _eq_int	# Booleans
	lw	$a2 String_protObj # load string tag
	bne	$v1 $a2 _eq_false  # Not a primitive type
_eq_str: # handle strings
	lw	$v0, str_size($t1)	# get string size objs
	lw	$v1, str_size($t2)
	lw	$v0, int_slot($v0)	# get string sizes
	lw	$v1, int_slot($v1)
	bne	$v1 $v0 _eq_false
	beqz	$v1 _eq_true		# 0 length strings are equal
	add	$t1 str_field		# Point to start of string
	add	$t2 str_field
	move	$t0 $v0		# Keep string length as counter
_eq_l1:
	lbu	$v0,0($t1)	# get char
	add	$t1 1
	lbu	$v1,0($t2)
	add	$t2 1
	bne	$v1 $v0 _eq_false
	addiu	$t0 $t0 -1	# Decrement counter
	bnez	$t0 _eq_l1
	b	_eq_true		# end of strings
		
_eq_int:	# handles booleans and ints
	lw	$v0,int_slot($t1)	# load values
	lw	$v1,int_slot($t2)
	bne	$v1 $v0 _eq_false
_eq_true:
	jr	$ra		# return true
_eq_false:
	move	$a0 $a1		# move false into accumulator
	jr	$ra

#
#  _dispatch_abort
#
#      filename in $a1
#      line number in $t1
#  
#  Prints error message and exits.
#  Called on dispatch to void.
#
	.globl	_dispatch_abort
_dispatch_abort:		 
        sw      $t1 0($sp)       # save line number
        addiu   $sp $sp -4
	addiu   $a0 $a1 str_field # adjust to beginning of string
	li      $v0 4
	syscall                  # print file name
	la      $a0 _colon_msg
	li	$v0 4
	syscall                  # print ":"
	lw      $a0 4($sp)       # 
	li	$v0 1
	syscall			 # print line number
	li 	$v0 4
	la	$a0 _dispatch_msg
	syscall			 # print dispatch-to-void message
	li   	$v0 10
        syscall			 # exit

#
#  _divide_abort
#
#      filename in $a1
#      line number in $t1
#  
#  Prints error message and exits.
#  Called on dispatch to void.
#
	.globl	_divide_abort
_divide_abort:		 
        sw      $t1 0($sp)       # save line number
        addiu   $sp $sp -4
	addiu   $a0 $a1 str_field # adjust to beginning of string
	li      $v0 4
	syscall                  # print file name
	la      $a0 _colon_msg
	li	$v0 4
	syscall                  # print ":"
	lw      $a0 4($sp)       # 
	li	$v0 1
	syscall			 # print line number
	li 	$v0 4
	la	$a0 _dvabort_msg
	syscall			 # print dispatch-to-void message
	li   	$v0 10
        syscall			 # exit

#
#
#  _case_abort
#		Is called when a case statement has no match
#
#   INPUT:	$a0 contains the object on which the case was
#		performed (may be void)
#		$a1 contains the filename
#		$t1 contains the line number
#
#   Does not return!
#
	.globl	_case_abort
_case_abort:			# $a0 contains case expression obj.
        sw      $t1 0($sp)      # save line number
        addiu   $sp $sp -4
	sw	$a0 0($sp)	# save the expression object
        addiu   $sp $sp -4
	addiu   $a0 $a1 str_field # adjust to beginning of string
	li      $v0 4
	syscall                  # print file name
	la      $a0 _colon_msg
	li	$v0 4
	syscall                  # print ":"
	lw      $a0 8($sp)       # 
	li	$v0 1
	syscall			 # print line number
	li 	$v0 4
	la	$a0 _cabort_msg
	li	$v0 4
	syscall			# print_str
	lw	$a0 4($sp)	# get expression object
	la	$t1 class_nameTab
	bne	$a0 0 case_abort_nonvoid
	la	$a0 _void_msg
	li	$v0 4
	syscall                  # print "void"
        b	case_abort_finish
case_abort_nonvoid:
	lw	$v0 obj_tag($a0)	# Get object tag
	sll	$v0 $v0 2	# *4
	addu	$t1 $t1 $v0
	lw	$t1 0($t1)	# Load class name string obj.
	addiu	$a0 $t1 str_field # Adjust to beginning of str
	li	$v0 4		# print_str
	syscall
case_abort_finish:
	la	$a0 _nl
	li	$v0 4		# print_str
	syscall
	li	$v0 10
	syscall			# Exit
	

#
#  Any constructor
#
#   Just return the copied prototype unchanged
#
	.globl	Any.Any
Any.Any:
	jr	$ra	# return self unchanged


#
# Copy method
#
#   Copies an object and returns a pointer to a new object in
#   the heap.  Note that to increase performance, the stack frame
#   is not set up unless it is absolutely needed.  As a result,
#   the frame is setup just before the call to "_MemMgr_Alloc" and
#   is destroyed just after it.  The increase in performance
#   occurs becuase the calls to "_MemMgr_Alloc" happen very
#   infrequently when the heap needs to be garbage collected.
#
#   INPUT:	$a0: object to be copied to free space in heap
#
#   OUTPUT:	$a0: points to the newly created copy.
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $v1, $a0, $a1, $a2, $gp, $s7
#

	.globl	Any.clone
Any.clone:
	addiu	$sp $sp -8			# create stack frame
	sw	$ra 8($sp)
	sw	$a0 4($sp)

	jal	_MemMgr_Test			# test GC area

	lw	$a0 4($sp)			# get object size
	lw	$a0 obj_size($a0)
	blez	$a0 _objcopy_error		# check for invalid size
	sll	$a0 $a0 2			# convert words to bytes
	addiu	$a0 $a0 4			# account for eyecatcher
	jal	_MemMgr_Alloc			# allocate storage
	addiu	$a1 $a0 4			# pointer to new object

	lw	$a0 4($sp)			# the self object
	lw	$ra 8($sp)			# restore return address
	addiu	$sp $sp 8			# remove frame
	lw	$t0 obj_size($a0)		# get size of object
	sll	$t0 $t0 2			# convert words to bytes
	b	_objcopy_allocated		# get on with the copy

# A faster version of Any.clone, for internal use (does not call
# _MemMgr_Test, and if possible not _MemMgr_Alloc)

_quick_copy:
	lw	$t0 obj_size($a0)		# get size of object to copy
	blez	$t0 _objcopy_error		# check for invalid size
	sll	$t0 $t0 2			# convert words to bytes
	addiu	$t1 $t0 4			# account for eyecatcher
	add	$gp $gp $t1			# allocate memory
	sub	$a1 $gp $t0			# pointer to new object
	blt	$gp $s7 _objcopy_allocated	# check allocation
_objcopy_allocate:
	sub	$gp $a1 4			# restore the original $gp
	addiu	$sp $sp -8			# frame size
	sw	$ra 8($sp)			# save return address
	sw	$a0 4($sp)			# save self
	move	$a0 $t1				# put bytes to allocate in $a0
	jal	_MemMgr_Alloc			# allocate storage
	addiu	$a1 $a0 4			# pointer to new object
	lw	$a0 4($sp)			# the self object
	lw	$ra 8($sp)			# restore return address
	addiu	$sp $sp 8			# remove frame
	lw	$t0 obj_size($a0)		# get size of object
	sll	$t0 $t0 2			# convert words to bytes
_objcopy_allocated:
	addiu	$t1 $0 -1
	sw	$t1 obj_eyecatch($a1)		# store eyecatcher
	add	$t0 $t0 $a0			# find limit of copy
	move	$t1 $a1				# save source
_objcopy_loop:
	lw	$v0 0($a0)			# copy word
	sw	$v0 0($t1)
	addiu	$a0 $a0 4			# update source
	addiu	$t1 $t1 4			# update destination
	bne	$a0 $t0 _objcopy_loop		# loop
_objcopy_end:
	move	$a0 $a1				# put new object in $a0
	jr	$ra				# return
_objcopy_error:
	la	$a0 _objcopy_msg		# show error message
	li	$v0 4
	syscall
	li	$v0 10				# exit
	syscall

#
#
# Any.equals
#
# Just compare the addresses
# 	
#   INPUT:	$a0 contains the object to compare from
#               4($sp) contains the object to which to compare
#
	.globl	Any.equals
Any.equals:
	lw	$t0 4($sp)
	move	$t1 $a0
	la	$a0 boolean_lit0
	bne	$t0 $t1 _ae_end
	la	$a0 boolean_lit1
_ae_end:
	addiu	$sp $sp 4
	jr	$ra

	
#
#
# IO.abort
#
#	The abort method for the IO class
#
#   INPUT:	$a0 contains the object on which abort() was dispatched.
#               4($sp) contains a string message
#

	.globl	IO.abort
IO.abort:
	move	$s0 $a0		# save self
	li	$v0 4
	la	$a0 _abort_msg
	syscall			# print_str
	lw	$t1 4($sp)
	addiu	$a0 $t1 str_field	# Adjust to beginning of str
	li	$v0 4		# print_str
	syscall
	la	$a0 _nl
	li	$v0 4
	syscall			# print new line
	li	$v0 10
	syscall			# Exit

#
#
# Any.toString
#
#   	INPUT:	$a0 object who's class name is desired
#	OUTPUT:	$a0 reference to class name string object
#
# NB: Much lamer than the Java/Scala version (no identifier)
# That would require a hash code in every object.

	.globl	Any.toString
Any.toString:
	la	$t1 class_nameTab
	lw	$v0 obj_tag($a0)	# Get object tag
	sll	$v0 $v0 2	# *4
	addu	$t1 $t1 $v0	# index table
	lw	$a0 0($t1)	# Load class name string obj.
	jr	$ra

#
#
# IO.out
#
#	Prints out the contents of a string object argument
#	which is on top of the stack.
#
#	$a0 is preserved!
#

	.globl	IO.out
IO.out:
	addiu	$sp $sp -4
	sw	$a0 4($sp)	# save self
	lw	$a0 8($sp)	# get arg
	beqz	$a0 _ioo_null	# check not null
	addiu	$a0 $a0 str_field	# Adjust to beginning of str
	li	$v0 4		# print_str
	syscall
	lw	$a0 4($sp)	# return self
	addiu	$sp $sp 8	# pop argument
	jr	$ra
_ioo_null:
	la	$a0 _ioabort_msg
	b	_ss_abort

#
#
# IO.out_int       NOT USED IN COOL 2009
#
#	Prints out the contents of an integer object on top of the
#	stack.
#
#	$a0 is preserved!
#

	.globl	IO.out_int
IO.out_int:
	addiu	$sp $sp -4
	sw	$a0 4($sp)	# save self
	lw	$a0 8($sp)	# get arg
	lw	$a0 int_slot($a0)	# Fetch int
	li	$v0 1		# print_int
	syscall	
	lw	$a0 4($sp)	# return self
	addiu	$sp $sp 8	# pop argument
	jr	$ra

#
#
# IO.in_int   NOT USED IN COOL 2009
#
#	Returns an integer object read from the terminal in $a0
#

	.globl	IO.in_int
IO.in_int:
	addiu	$sp $sp -4
	sw	$ra 4($sp)	# save return address

        la      $a0 Int_protObj
        jal     _quick_copy	# Call copy

	addiu	$sp $sp -4
	sw	$a0 4($sp)	# save new object

	li	$v0, 5		# read int
	syscall

	lw	$a0 4($sp)
	addiu	$sp $sp 4


	sw	$v0 int_slot($a0)	# store int read into obj
	lw	$ra 4($sp)
	addiu	$sp $sp 4
	jr	$ra

#
#
# IO.in
#
#	Returns a string object read from the terminal, removing the
#	'\n'
#
#	OUTPUT:	$a0 the read string object
#

	.globl	IO.in
IO.in:
	addiu	$sp $sp -8
	sw	$ra 8($sp)			# save return address
	sw	$0 4($sp)			# init GC area

	jal	_MemMgr_Test			# test GC area

	la	$a0 Int_protObj		# Int object for string size
	jal	_quick_copy
	sw	$a0 4($sp)			# save it

	li	$a0 str_field			# size of string obj. header
	addiu	$a0 $a0 str_maxsize		# max size of string data
	jal	_MemMgr_QAlloc			# make sure enough room

	la	$a0 String_protObj		# make string object
	jal	_quick_copy
	lw	$t0 4($sp)			# get size object
	sw	$t0 str_size($a0)		# store size object in string
	sw	$a0 4($sp)			# save string object

	addiu	$gp $gp -4			# overwrite last word

_instr_ok:
	li	$a1 str_maxsize			# largest string to read
	move	$a0 $gp	
	li	$v0, 8				# read string
	syscall

	move	$t0 $gp				# t0 to beginning of string
_instr_find_end:
	lb	$v0 0($gp)
	addiu	$gp $gp 1
	bnez	$v0 _instr_find_end

	# $gp points just after the null byte
	lb	$v0 0($t0)			# is first byte '\0'?
	bnez	$v0 _instr_noteof

	# we read nothing. Return null
	lw	$a0 4($sp)
	move	$gp $a0
	li	$a0 0
	b	_instr_ret

_instr_noteof:
	# Check if there really is a '\n'
	lb	$v0 -2($gp)
	bne	$v0 10 _instr_nonl

	# Write '\0' over '\n'
	sb	$zero -2($gp)			# Set end of string where '\n' was
	addiu	$gp $gp -1			# adjust for '\n'

_instr_nonl:
	lw	$a0 4($sp)			# get pointer to new str obj
	lw	$t1 str_size($a0)		# get pointer to int obj

	sub	$t0 $gp $a0
	subu	$t0 str_field			# calc actual str size
	addiu	$t0  -1				# adjust for '\0'
	sw	$t0 int_slot($t1)		# store string size in int obj
	addi	$gp $gp 3			# was already 1 past '\0'
	and	$gp $gp -4			# word align $gp

	sub	$t0 $gp $a0			# calc length
	srl	$t0 $t0 2			# divide by 4
	sw	$t0 obj_size($a0)		# set size field of obj

_instr_ret:
	lw	$ra 8($sp)			# restore return address
	addiu	$sp $sp 8
	jr	$ra				# return

	
	.globl Int.Int
Int.Int:
	jr $ra

#
# Int.equals
#		Returns Boolean Obj with result of test
#
# An integer object is equal to another integer object with the same value.
#
#	INPUT:  $a0 the integer object
#		Top of stack: the other object (may be void or not an integer)
#	OUTPUT: $a0 the bool object which is the result of comparison
#
	.globl	Int.equals
Int.equals:
	beq	$a0 $zero Int.equals_false	# don't handle void
	lw	$t1 4($sp)			# get argument into $t1
	beq	$t1 $zero Int.equals_false	# don't compare to void
	lw	$t2 obj_tag($t1)		# get tag
	lw	$t3 Int_protObj			# test for int object
	bne	$t2 $t3 Int.equals_false	# if not, return false
	lw	$t0 int_slot($a0)		# get this integer value
	lw	$t1 int_slot($t1)		# get other integer value
	la	$a0 boolean_lit1	
	beq	$t0 $t1 Int.equals_return	# if equal return true
Int.equals_false:
	la	$a0 boolean_lit0
Int.equals_return:
	addiu	$sp $sp 4
	jr	$ra


#
# Int.toString
#		Returns string object representing integer
#
# Allocate a new string (and new size) holding characters for integer
#
#	INPUT:  $a0 the integer object
#
#	OUTPUT: $a0 the string object which is the result of conversion
#
# We use some temporary data space
	.data
_i2s_rev:
	.asciiz "-2147483648"
	.byte 0
_i2s_rev1:
	.ascii "8463847412-"
_i2s_rev1end:	
	.align	2
	.word -1
_i2s_fake_str:
	.word 0
	.word 7
	.word 0
	.word 0
	.asciiz "-2147483648"
	.align 2
	
	.text
	.globl	Int.toString
Int.toString:
	la	$a1 _i2s_fake_str
	lw	$t0 int_slot($a1)	# check if inited
	bnez	$t0 _i2s_start
	la	$t0 String_protObj	# start with prototype
	lw	$t1 obj_tag($t0)	# copy over tag
	sw	$t1 obj_tag($a1)
	lw	$t1 obj_disp($t0)	# copy over dispatch table
	sw	$t1 obj_disp($a1)
_i2s_start:
	addiu	$sp $sp -4		# space for RA
	sw	$ra 4($sp)
	jal	Any.clone		# copy Int object	
	lw	$t0 int_slot($a0)	# get raw number
	la	$a2 _i2s_rev		# get start of buffer
	beqz	$t0 _i2s_zero		# special case
	li	$t1 0x80000000		# special case (MININT)
	beq	$t0 $t1 _i2s_minint
	move	$a3 $a2			# current point of buffer
	li	$v0 0
	bgt	$t0 $zero _i2s_pos	# negative requires special:
	li	$v0 1			# save negative
	sub	$t0 $zero $t0		# force positive
_i2s_pos:
	li	$t1 10
	div	$t0 $t1			# div/mod with 10
	mflo	$t0
	mfhi	$t1
	addi	$t1 $t1 48		# make an ASCII digit
	sb	$t1 0($a3)
	addiu	$a3 $a3 1		# store into buffer
	bnez	$t0 _i2s_pos		# until number is zero
	beqz	$v0 _i2s_copy		# if positive, done
	li	$t0 45			# get '-'
	sb	$t0 0($a3)
	addiu	$a3 $a3 1		# store in buffer
_i2s_copy:
	sub	$t0 $a3 $a2		# get length into $t0
	sw	$t0 int_slot($a0)	# update length object
	la	$a1 _i2s_fake_str
	sw	$a0 int_slot($a1)	# store in fake string
_i2s_copy_loop:
	addiu	$a3 $a3 -1
	lb	$t1 0($a3)
	sb	$t1 str_field($a1)
	addiu	$a1 $a1 1
	bne	$a2 $a3 _i2s_copy_loop
	sb	$zero str_field($a1)	# terminate with NUL
	la	$a0 _i2s_fake_str
	lw	$ra 4($sp)
	addiu	$sp $sp 4
	
	j	Any.clone

	# special cases

_i2s_zero:
	li	$t0 48
	sb	$t0 0($a2)
	addiu	$a3 $a2 1
	b	_i2s_copy
	
_i2s_minint:
	la	$a2 _i2s_rev1
	la	$a3 _i2s_rev1end
	b	_i2s_copy

	
	.globl Boolean.Boolean
Boolean.Boolean:
	jr $ra

#
# Boolean.equals
#		Returns Boolean Obj with result of test
#
# An boolean object is equal to another boolean object with the same value.
#
#	INPUT:  $a0 the boolean object
#		Top of stack: the other object (may be void or not an boolean)
#	OUTPUT: $a0 the bool object which is the result of comparison
#
	.globl	Boolean.equals
Boolean.equals:
	beq	$a0 $zero Boolean.equals_false	# don't handle void
	lw	$t1 4($sp)			# get argument into $t1
	beq	$t1 $zero Boolean.equals_false	# don't compare to void
	lw	$t2 obj_tag($t1)		# get tag
	lw	$t3 Boolean_protObj			# test for bool object
	bne	$t2 $t3 Boolean.equals_false	# if not, return false
	lw	$t0 bool_slot($a0)		# get this boolean value
	lw	$t1 bool_slot($t1)		# get other boolean value
	la	$a0 boolean_lit1
	beq	$t0 $t1 Boolean.equals_return	# if equal return true
Boolean.equals_false:
	la	$a0 boolean_lit0
Boolean.equals_return:
	addiu	$sp $sp 4			# pop argument
	jr	$ra


#
# String constructor.  This does nothing.
# It returns the empty string (copied prototype) unchanged.
#
	.globl String.String
String.String:
	jr	$ra

#
# String.equals
#		Returns Boolean Obj with result of test
#
# An string object is equal to another string object with the same chars.
#
#	INPUT:  $a0 the string object
#		Top of stack: the other object (may be void or not an string)
#	OUTPUT: $a0 the bool object which is the result of comparison
#
	.globl	String.equals
String.equals:
	beq	$a0 $zero String.equals_false	# don't handle void
	lw	$t2 4($sp)			# get argument
	beq     $t2 $zero String.equals_false	# $t1 can't also be void   
	lw	$v0 obj_tag($a0)		# get tags
	lw	$v1 obj_tag($t2)
	bne	$v1 $v0 String.equals_false	# compare tags
	lw	$v0, str_size($a0)		# get string size objs
	lw	$v1, str_size($t2)
	lw	$v0, int_slot($v0)		# get string sizes
	lw	$v1, int_slot($v1)
	bne	$v1 $v0 String.equals_false
	beqz	$v1 String.equals_true		# 0 length strings are equal
	add	$t1 $a0, str_field		# Point to start of string
	add	$t2 str_field
	move	$t0 $v0				# Keep str length as counter
String.equals_l1:
	lbu	$v0,0($t1)	# get char
	add	$t1 1
	lbu	$v1,0($t2)
	add	$t2 1
	bne	$v1 $v0 String.equals_false
	addiu	$t0 $t0 -1	# Decrement counter
	bnez	$t0 String.equals_l1
String.equals_true:
	la	$a0 boolean_lit1
	b	String.equals_return
String.equals_false:
	la	$a0 boolean_lit0
String.equals_return:
	addiu	$sp $sp 4	# pop argument
	jr	$ra

#
# String.concat
#
#   Concatenates arg1 onto the end of self and returns a pointer
#   to the new object.
#
#	INPUT:	$a0: the first string object (self)
#		Top of stack: the second string object (arg1)
#
#	OUTPUT:	$a0 the new string object
#

	.globl	String.concat
String.concat:

	addiu	$sp $sp -16
	sw	$ra 16($sp)			# save return address
	sw	$a0 12($sp)			# save self arg.
	sw	$0 8($sp)			# init GC area
	sw	$0 4($sp)			# init GC area

	jal	_MemMgr_Test			# test GC area

	lw	$a0 12($sp)
	lw	$a0 str_size($a0)
	jal     _quick_copy			# Call copy
	sw	$a0 8($sp)			# save new size object


	lw	$t1 20($sp)			# load arg object
	lw	$t1 str_size($t1)		# get size object
	lw	$t1 int_slot($t1)		# arg string size
	blez	$t1 _strcat_argempty		# nothing to add
	lw	$t0 12($sp)			# load self object
	lw	$t0 str_size($t0)		# get size object
	lw	$t0 int_slot($t0)		# self string size
	addu	$t0 $t0 $t1			# new size
	sw	$t0 int_slot($a0)		# store new size

	addiu	$a0 $t0 str_field		# size to allocate
	addiu	$a0 $a0 4			# include '\0', +3 to align
	and	$a0 $a0 -4			# align on word boundary
	addiu   $a0 $a0 1                       # make size odd for GC <-|
	sw	$a0 4($sp)			# save size in bytes     |
	addiu	$a0 $a0 3			# include eyecatcher(4) -1
	jal	_MemMgr_QAlloc			# check memory

	lw	$a0 12($sp)			# copy self
	jal	_quick_copy			# Call copy
	lw	$t0 8($sp)			# get the Int object
	sw	$t0 str_size($a0)		# store it in the str obj.

	sub	$t1 $gp $a0			# bytes allocated by _quick_copy
	lw	$t0 4($sp)			# get size in bytes (no eyecatcher)
	sub     $t0 $t0 1                       # Remove extra 1 (was for GC)
	sub	$t1 $t0 $t1			# more memory needed
	addu	$gp $gp $t1			# allocate rest
	srl	$t0 $t0 2			# convert to words
	sw	$t0 obj_size($a0)		# save new object size

	lw	$t0 12($sp)			# get original self object
	lw	$t0 str_size($t0)		# get size object
	lw	$t0 int_slot($t0)		# self string size
	addiu	$t1 $a0 str_field		# points to start of string data
	addu	$t1 $t1 $t0			# points to end: '\0'
	lw	$t0 20($sp)			# load arg object
	addiu	$t2 $t0 str_field		# points to start of arg data
	lw	$t0 str_size($t0)		# get arg size
	lw	$t0 int_slot($t0)
	addu	$t0 $t0 $t2			# find limit of copy

_strcat_copy:
	lb	$v0 0($t2)			# load from source
	sb	$v0 0($t1)			# save in destination
	addiu	$t2 $t2 1			# advance each index
	addiu	$t1 $t1 1
	bne	$t2 $t0 _strcat_copy		# check limit
	sb	$0 0($t1)			# add '\0'

	lw	$ra 16($sp)			# restore return address
	addiu	$sp $sp 20			# pop argument
	jr	$ra				# return

_strcat_argempty:
	lw	$a0 12($sp)			# load original self
	lw	$ra 16($sp)			# restore return address
	addiu	$sp $sp 20			# pop argument
	jr	$ra				# return

# WARNING: There are two substring functions.
# The one declared here (first: String.substring) is for Cool 2009
# It uses the other as a subroutine (easier
# than all the complex assembly language programming
# to do it all natively.
	
#
# String.substring(i,j)
#               Returns the sub string of self from i to j
#               Offset starts at 0.
#
#	INPUT:	$a0 the string
#		end index int object on top of stack (-4)
#		index int object below length on stack (-8)
#	OUTPUT:	The substring object in $a0
#
	.globl	String.substring
String.substring:
	addiu	$sp $sp -8
	sw	$ra 4($sp)		# save RA
	sw	$a0 8($sp)		# save string in temp
	lw	$a0 12($sp)		# get end index
	jal	Any.clone	  	# copy it!
	lw	$t1 16($sp)	  	# get start index
	lw	$t1 int_slot($t1) 	# ... as raw int
	lw	$t2 int_slot($a0) 	# get end index
	sub	$t2 $t2 $t1
	sw	$t2 int_slot($a0)	# save difference in copied int
	sw	$a0 12($sp)		# place back on stack (as length)
	lw	$a0 8($sp)	  	# get saved string
	lw	$ra 4($sp)		# get return address
	addiu	$sp $sp 8		# pop frame
	j	String.substr	  	# do the other routine


#
#
# String.substr(i,l)
#		Returns the sub string of self from i l long
#		Offset starts at 0.
#
#	INPUT:	$a0 the string
#		length int object on top of stack (-4)
#		index int object below length on stack (-8)
#	OUTPUT:	The substring object in $a0
#

	.globl	String.substr
String.substr:
	addiu	$sp $sp -12		# frame
	sw	$ra 4($sp)		# save return
	sw	$a0 12($sp)		# save self
	sw	$0 8($sp)		# init GC area

	jal	_MemMgr_Test		# test GC area

	lw	$a0 12($sp)
	lw	$v0 obj_size($a0)
        la      $a0 Int_protObj	# ask if enough room to allocate
	lw	$a0 obj_size($a0)	#   a string object, an int object,
	add	$a0 $a0 $v0		#   and the string data
	addiu	$a0 $a0 2		# include 2 eyecatchers
	sll	$a0 $a0 2
	addi	$a0 $a0 str_maxsize
	jal	_MemMgr_QAlloc

_ss_ok:
	la	$a0 Int_protObj
	jal	_quick_copy
	sw	$a0 8($sp)	# save new length obj
	la	$a0 String_protObj
	jal	_quick_copy
	move	$a2 $a0		# use a2 to make copy
	addiu	$gp $gp -4	# backup alloc ptr
	lw	$a1 12($sp)	# load orig
	lw	$t1 20($sp)	# index obj
	lw	$t2 16($sp)	# length obj
	lw	$t0 str_size($a1)
	lw	$v1 int_slot($t1) # index
	lw	$v0 int_slot($t0) # size of orig
	bltz	$v1 _ss_abort1	# index is smaller than 0
	bgt	$v1 $v0 _ss_abort2	# index > orig
	lw	$t3 int_slot($t2) # sub length
	add	$v1 $v1 $t3	# index+sublength
	bgt	$v1 $v0 _ss_abort3
	bltz	$t3 _ss_abort4
	lw	$t4 8($sp)	# load new length obj
	sw	$t3 int_slot($t4) # save new size
	sw	$t4 str_size($a0) # store size in string
	lw	$v1 int_slot($t1) # index
	addiu	$a1 $a1 str_field # advance src to str
	add	$a1 $a1 $v1	  # advance to indexed char
	addiu	$a2 $a2 str_field # advance dst to str
	beqz	$t3 _ss_end	  # empty length
_ss_loop:
	lb	$v0 0($a1)
	addiu	$a1 $a1 1	# inc src
	sb	$v0 0($a2)
	addiu	$a2 $a2 1	# inc dst
	addiu	$t3 $t3 -1	# dec ctr
	bnez	$t3 _ss_loop
_ss_end:
	sb	$zero 0($a2)	# null terminate
	move	$gp $a2
	addiu	$gp $gp 4	# realign the heap ptr
	and	$gp $gp -4

	sub	$t0 $gp $a0	# calc object size
	srl	$t0 $t0 2	# div by 4
	sw	$t0 obj_size($a0)

	lw	$ra 4($sp)
	addiu	$sp $sp 20	# pop arguments
	jr	$ra

_ss_abort1:
	la	$a0 _sabort_msg1
	b	_ss_abort
_ss_abort2:
	la	$a0 _sabort_msg2
	b	_ss_abort
_ss_abort3:
	la	$a0 _sabort_msg3
	b	_ss_abort
_ss_abort4:
	la	$a0 _sabort_msg4
_ss_abort:
	li	$v0 4
	syscall
	la	$a0 _sabort_msg
	li	$v0 4
	syscall
	li	$v0 10		# exit
	syscall

#
#
# String.charAt(i)
#		Return the ASCII value of the character at location i
#
#	INPUT:	$a0 the string, 4($sp) Int object for index
#	OUTPUT:	The Int object in $a0
#
	.globl	String.charAt
String.charAt:
	addiu	$sp $sp -8
	sw	$ra 8($sp)
	sw	$a0 4($sp)
	lw	$a0 str_size($a0)
	jal	Any.clone	# get a fresh integer object
	lw	$t1 12($sp)
	lw	$t1 int_slot($t1) # get index as raw int
	lw	$t2 int_slot($a0) # get length as raw int
	blt	$t1 $zero _sc_abort1
	ble	$t2 $t1 _sc_abort2
	lw	$a1 4($sp)	# get string into $a1
	addu	$a1 $a1 $t1
	lbu	$t0 str_field($a1) # get first byte
	sw	$t0 int_slot($a0) # store in integer
	lw	$ra 8($sp)
	addiu	$sp $sp 12
	jr	$ra
_sc_abort1:
	la	$a0 _scharat_msg1
	b	_ss_abort
_sc_abort2:	
	la	$a0 _scharat_msg1
	b	_ss_abort

	
#
#  Symbols are new to Cool 2009
#  They must be primitive since Cool has no globals.
#
	.globl Symbol.Symbol
Symbol.Symbol:
	jr $ra

	.globl IO.symbol_name
IO.symbol_name:
	lw	$a0 4($sp)
	beqz	$a0 _isn_null
	addiu	$sp $sp 4
	# fall through
	.globl Symbol.name
Symbol.name:
	lw	$a0 sym_name($a0)
	jr	$ra
_isn_null:
	la	$a0 _snabort_msg
	b	_ss_abort

	.globl IO.symbol
IO.symbol:
	lw	$a1 4($sp)		# $a1 = Cool string argument
	la	$a0 Symbol_protObj	# forget IO, get starting symbol
	beqz	$a1 _is_done		# null gets prototype
_is_loop:	
	lw	$a2 sym_next($a0)	# next symbol ?
	beqz	$a2 _is_alloc		# if null, we need to make a symbol
	move	$a0 $a2			# next symbol is now current
	lw	$t0 sym_name($a0)	# get name of current
	la	$t0 str_field($t0)	# $t0 = raw string of current
	la	$t1 str_field($a1)	# $t1 = raw string of argument
_is_strcmp_loop:
	lb	$v0 0($t0)		# compare two strings ...
	lb	$v1 0($t1)	
	bne	$v0 $v1 _is_loop	# .. if any differences go is_loop
	addiu	$t0 $t0 1		# if equal, move on, ...
	addiu	$t1 $t1 1
	bnez	$v0 _is_strcmp_loop	# .. but stop if at end of strings
_is_done:	
	addiu	$sp $sp 4		# pop parameter
	jr	$ra
	
_is_alloc:
	addiu	$sp $sp -8		# push two (more) words on stack
	sw	$ra 12($sp)		# save return address
	sw	$a0 8($sp)		# save last symbol
	sw	$a1 4($sp)		# save symbol name
	jal	Any.clone		# copy last symbol
	lw	$a1 4($sp)		# get name
	sw	$a1 sym_name($a0)	# save it
	lw	$a1 8($sp)		# get last symbol
	sw	$a0 sym_next($a1)	# save link to new in last
	sw	$a0 8($sp)		# new symbol -> temp 8 (was last sym)
	lw	$a0 sym_hash($a1)	# get old hashcode
	jal	Any.clone		# copy it
	lw	$t0 int_slot($a0)	# increment raw value
	addi	$t0 $t0 1
	sw	$t0 int_slot($a0)	# store updated hash code value
	move	$a1 $a0			# get hashcode out of $a0
	lw	$a0 8($sp)		# get new symbol
	sw 	$a1 sym_hash($a0)	# save hash code
	lw	$ra 12($sp)		# restore RA
	addiu	$sp $sp 12		# pop frame (inc. param)
	jr	$ra

	
	#
	# STATISTICS EXTENSION
	#
	# This only works with the jtb stats patch on spim.
	#
	
	.globl	Statistics.clear
Statistics.clear:
	mtc2	$zero	$0
	mtc2	$zero	$1
	mtc2	$zero	$2
	mtc2	$zero	$3
	jr	$ra

	.data
	.word -1
Statistics_fake_int:
	.word 0
	.word 0
	.word 0
	.word 0

	.text
	.globl	Statistics.get4
Statistics.get4:
	mfc2	$t0	$0
	mfc2	$t1	$1
	mfc2	$t2	$2
	mfc2	$t3	$3

	sll	$t1	$t1	8
	sll	$t2	$t2	16
	sll	$t3	$t3	24
	addu	$t0	$t0	$t1
	addu	$t2	$t2	$t3
	addu	$t0	$t0	$t2
	la	$a0	Statistics_fake_int
	la	$a1	Int_protObj
	lw	$t1 	0($a1)
	lw	$t2	4($a1)
	lw	$t3	8($a1)
	sw	$t1	0($a0)
	sw	$t2	4($a0)
	sw	$t3	8($a0)
	sw	$t0	12($a0)
	j	Any.clone
	
	.globl	Statistics.get
Statistics.get:
	lw	$a0	4($sp)
	lw	$t0	12($a0)
	bnez	$t0	stg_nonzero
	mfc2	$t0	$0
	b	stg_done
stg_nonzero:
	addiu	$t0	$t0	-1
	bnez	$t0	stg_nonone
	mfc2	$t0	$1
	b	stg_done
stg_nonone:
	addiu	$t0	$t0	-1
	bnez	$t0	stg_nontwo
	mfc2	$t0	$2
	b	stg_done
stg_nontwo:
	addiu	$t0	$t0	-1
	bnez	$t0	stg_nostat
	mfc2	$t0	$3
	b	stg_done
stg_nostat:
	li	$t0	0
stg_done:
	la	$a0	Statistics_fake_int
	la	$a1	Int_protObj
	lw	$t1 	0($a1)
	lw	$t2	4($a1)
	lw	$t3	8($a1)
	sw	$t1	0($a0)
	sw	$t2	4($a0)
	sw	$t3	8($a0)
	sw	$t0	12($a0)
	addiu	$sp	$sp	4
	j	Any.clone

	.data
stp_s1:	.asciiz	"Statistics: executed "
stp_s2:	.asciiz	" instructions, of which\n  branches: "
stp_s3:	.asciiz	"  loads: "
stp_s4:	.asciiz	"  stores: "
stp_s5:	.asciiz	"\n"

	.text
	.globl	Statistics.print
Statistics.print:
	mfc2	$t0	$0
	mfc2	$t1	$1
	mfc2	$t2	$2
	mfc2	$t3	$3
	addiu	$t0	$t0	-6
	addiu	$t1	$t1	-2
	li	$v0	4
	la	$a0	stp_s1
	syscall
	li	$v0	1
	move	$a0	$t0
	syscall
	li	$v0	4
	la	$a0	stp_s2
	syscall
	li	$v0	1
	move	$a0	$t1
	syscall
	li	$v0	4
	la	$a0	stp_s3
	syscall
	li	$v0	1
	move	$a0	$t2
	syscall
	li	$v0	4
	la	$a0	stp_s4
	syscall
	li	$v0	1
	move	$a0	$t3
	syscall
	li	$v0	4
	la	$a0	stp_s5
	syscall
	jr	$ra

#
# MemMgr Memory Manager
#
#   The MemMgr functions give a consistent view of the garbage collectors.
#   This allows multiple collectors to exist in one file and the easy
#   selection of different collectors.  It includes functions to initialize
#   the collector and to reserve memory and query its status.
#
#   The following assumptions are made:
#
#     1) The allocation of memory involves incrementing the $gp pointer.
#        The $s7 pointer serves as a limit.  The collector function is
#        called before $s7 is exceeded by $gp.
#
#     2) The initialization functions all take the same arguments as
#        defined in "_MemMgr_Init".
#
#     3) The garbage collector functions all take the arguments.  "$a0"
#        contains the end of the stack to check for pointers.  "$a1"
#        contains the size in bytes needed by the program and must be
#        preserved across the function call.
#

#
# Initialize the Memory Manager
#
#   Call the initialization routine for the garbage collector.
#
#   INPUT:
#	$a0: start of stack
#	$a1: initial Register mask
#	$a2: end of heap
#	heap_start: start of the heap
#
#   OUTPUT:
#	$gp: lower bound of the work area
#	$s7: upper bound of the work area
#
#   Registers modified:
#	$t0, initializer function
#

	.globl _MemMgr_Init
_MemMgr_Init:
	addiu	$sp $sp -4
	sw	$ra 4($sp)			# save return address
	la	$t0 _MemMgr_INITIALIZER		# pointer to initialization
	lw	$t0 0($t0)
	jalr	$t0				# initialize
	lw	$ra 4($sp)			# restore return address
	addiu	$sp $sp 4
	jr	$ra				# return

#
# Memory Allocation
#
#   Allocates the requested amount of memory and returns a pointer
#   to the start of the block.
#
#   INPUT:
#	$a0: size of allocation in bytes
#	$s7: limit pointer of the work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   OUTPUT:
#	$a0: pointer to new memory block
#
#   Registers modified:
#	$t0, $a1, collector function
#

	.globl _MemMgr_Alloc
_MemMgr_Alloc:
	add	$gp $gp $a0			# attempt to allocate storage
	blt	$gp $s7 _MemMgr_Alloc_end	# check allocation
	sub	$gp $gp $a0			# restore $gp
	addiu	$sp $sp -4
	sw	$ra 4($sp)			# save return address
	move	$a1 $a0				# size
	addiu	$a0 $sp 4			# end of stack to collect
	la	$t0 _MemMgr_COLLECTOR		# pointer to collector function
	lw	$t0 0($t0)
	jalr	$t0				# garbage collect
	lw	$ra 4($sp)			# restore return address
	addiu	$sp $sp 4
	move	$a0 $a1				# put size into $a0
	add	$gp $gp $a0			# allocate storage
_MemMgr_Alloc_end:
	sub	$a0 $gp $a0
	jr	$ra				# return

#
# Query Memory Allocation
#
#   Verifies that the requested amount of memory can be allocated
#   within the work area.
#
#   INPUT:
#	$a0: size of allocation in bytes
#	$s7: limit pointer of the work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   OUTPUT:
#	$a0: size of allocation in bytes (unchanged)
#
#   Registers modified:
#	$t0, $a1, collector function
#

	.globl _MemMgr_QAlloc
_MemMgr_QAlloc:
	add	$t0 $gp $a0			# attempt to allocate storage
	blt	$t0 $s7 _MemMgr_QAlloc_end	# check allocation
	addiu	$sp $sp -4
	sw	$ra 4($sp)			# save return address
	move	$a1 $a0				# size
	addiu	$a0 $sp 4			# end of stack to collect
	la	$t0 _MemMgr_COLLECTOR		# pointer to collector function
	lw	$t0 0($t0)
	jalr	$t0				# garbage collect
	lw	$ra 4($sp)			# restore return address
	addiu	$sp $sp 4
	move	$a0 $a1				# put size into $a0
_MemMgr_QAlloc_end:
	jr	$ra				# return

#
# Test heap consistency
#
#   Runs the garbage collector in the hope that this will help detect
#   garbage collection bugs earlier.
#
#   INPUT: (the usual GC stuff)
#	$s7: limit pointer of the work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   OUTPUT:
#	none
#
#   Registers modified:
#	$t0, $a1, collector function

	.globl	_MemMgr_Test
_MemMgr_Test:
	la	$t0 _MemMgr_TEST		# Check if testing enabled
	lw	$t0 0($t0)
	beqz	$t0 _MemMgr_Test_end

# Allocate 0 bytes
	addiu	$sp $sp -4			# Save return address
	sw	$ra 4($sp)
	li	$a1 0				# size = 0
	addiu	$a0 $sp 4			# end of stack to collect
	la	$t0 _MemMgr_COLLECTOR		# pointer to collector function
	lw	$t0 0($t0)
	jalr	$t0				# garbage collect
	lw	$ra 4($sp)			# restore return address
	addiu	$sp $sp 4

_MemMgr_Test_end:
	jr	$ra

#
# GenGC Generational Garbage Collector
#
#   This is an implementation of a generational garbage collector
#   as described in "Simple Generational Garbage Collection and Fast
#   Allocation" by Andrew W. Appel [Princeton University, March 1988].
#   This is a two generation scheme which uses an assignment table
#   to handle root pointers located in the older generation objects.
#
#   When the work area is filled, a minor garbage collection takes place
#   which moves all live objects into the reserve area.  These objects
#   are then incorporated into the old area.  New reserve and work areas
#   are setup and allocation can continue in the work area.  If a break-
#   point is reached in the size of the old area just after a minor
#   collection, a major collection then takes place.  All live objects in
#   the old area are then copied into the new area, expanding the heap if
#   necessary.  The X and new areas are then block copied back L1-L0
#   bytes to form the next old area.
#
#   The assignment table is implemented as a stack growing towards the
#   allocation pointer ($gp) in the work area.  If they cross, a minor
#   collection is then carried out.  This allows the garbage collector to
#   to have to keep a fixed table of assignments.  As a result, programs
#   with many assignments will tend not to be bogged down with extra
#   garbage collections.
#
#   The unused area was implemented to help keep the garbage collector
#   from continually expanding the heap.  This buffer zone allows major
#   garbage collections to happen earlier, reducing the risk of expansions
#   due to too many live objects in the old area.  The histories kept by
#   the garbage collector in MAJOR0, MAJOR1, MINOR0, and MINOR1 also help
#   to prevent unnecessary expansions of the heap.  If many live objects
#   were recently collected, the garbage collections will start to occur
#   sooner.
#
#   Note that during a minor collection, the work area is guaranteed to
#   fit within the reserve area.  However, during a major collection, the
#   old area will not necessarily fit in the new area.  If the latter occurs,
#   "_GenGC_OfsCopy" will detect this and expand the heap.
#
#   The heap is expanded on two different occasions:
#
#     1) After a major collection, the old area is set to be at most
#        1/(2^GenGC_OLDRATIO) of the usable heap (L0 to L3).  Note that
#        first L4 is checked to see if any of the unused memory between L3
#        and L4 is enough to satisfy this requirement.  If not, then the
#        heap will be expanded.  If it is, the appropriate amount will be
#        transfered from the unused area to the work/reserve area.
#
#     2) During a major collection, if the live objects in the old area
#        do not fit within the new area, the heap is expanded and $s7
#        is updated to reflact this.  This value later gets stored back
#        into L4.
#
#   During a normal allocation and minor collections, the heap has the
#   following form:
#
#      Header
#       |
#       |   Older generation objects
#       |    |
#       |    |             Minor garbage collection area
#       |    |              |
#       |    |              |                Allocation area
#       |    |              |                 |
#       |    |              |                 |           Assignment table
#       |    |              |                 |            |
#       |    |              |                 |            |   Unused
#       |    |              |                 |            |    |
#       v    v              v                 v            v    v
#     +----+--------------+-----------------+-------------+---+---------+
#     |XXXX| Old Area     | Reserve Area    | Work Area   |XXX| Unused  |
#     +----+--------------+-----------------+-------------+---+---------+
#      ^    ^              ^                 ^    ^        ^   ^         ^
#      |    |              |                 |    |-->  <--|   |         |
#      |    L0             L1                L2  $gp      $s7  L3        L4
#      |
#     heap_start
#
#     $gp (allocation pointer): points to the next free word in the work
#         area during normal allocation.  During a minor garbage collection,
#         it points to the next free work in the reserve area.
#
#     $s7 (limit pointer): points to the limit that $gp can traverse.  Between
#         it and L3 sits the assignment table which grows towards $gp.
#
#   During a Major collection, the heap has the following form:
#
#      Header
#       |
#       |   Older generation objects
#       |    |
#       |    |                 Objects surviving last minor garbage collection
#       |    |                  |
#       |    |                  |         Major garbage collection area
#       |    |                  |          |
#       v    v                  v          v
#     +----+------------------+----------+------------------------------+
#     |XXXX| Old Area         | X        | New Area                     |
#     +----+------------------+----------+------------------------------+
#      ^    ^                  ^      ^   ^      ^                       ^
#      |    |                  |      |   |      |-->                    |
#      |    L0                 L1     |   L2    $gp                   L4, $s7
#      |                              |
#     heap_start                     breakpoint
#
#     $gp (allocation pointer): During a major collection, this points
#         into the next free word in the new area.
#
#     $s7 (limit pointer): During a major collection, the points to the
#         limit of heap memory.  $gp is not allowed to pass this value.
#         If the objects in the live old area cannot fit in the new area,
#         more memory is allocated and $s7 is adjusted accordingly.
#
#     breakpoint: Point where a major collection will occur.  It is
#         calculated by the following formula:
#
#         breakpoint = MIN(L3-MAX(MAJOR0,MAJOR1)-MAX(MINOR0,MINOR1),
#                          L3-(L3-L0)/2)
#
#         where (variables stored in the header):
#           MAJOR0 = total size of objects in the new area after last major
#                    collection.
#           MAJOR1 = (MAJOR0+MAJOR1)/2
#           MINOR0 = total size of objects in the reserve area after last
#                    minor collection.
#           MINOR1 = (MINOR0+MINOR1)/2
#
#   The following assumptions are made in the garbage collection
#   process:
#
#     1) Pointers on the Stack:
#        Every word on the stack that ends in 0 (i.e., is even) and is
#	 a valid address in the heap is assumed to point to an object
#        in the heap.  Even heap addresses on the stack that are actually
#	 something else (e.g., raw integers) will probably cause an
#        garbage collection error.
#
#     2) Object Layout:
#        Besides the Int, String, and Bool objects (which are handled
#        separately), the garbage collector assumes that each attribute
#        in an object is a pointer to another object.  It, however,
#        still does as much as possible to verify this before actually
#        updating any fields.
#
#     3) Pointer tests:
#        In order to be verified as an object, a pointer must undergo
#        certain tests:
#
#          a) The pointer must point within the correct storage area.
#          b) The word before the pointer (obj_eyecatch) must be the
#             word 0xFFFF FFFF
#          c) The word at the pointer must not be 0xFFFF FFFF (i.e.
#             -1 cannot be a class tag)
#
#        These tests are performed whenever any data could be a pointer
#        to keep any non-pointers from being updated accidentally.  The
#        functions "_GenGC_ChkCopy" and "_GenGC_OfsCopy" are responsible
#        for these checks.
#
#     4) The size stored in the object does not include the word required
#        to store the eyecatcher for the object in the heap.  This allows
#        the prototype objects to not require its own eyecatcher.  Also,
#        a size of 0 is invalid because it is used as a flag by the garbage
#        collector to indicate a forwarding pointer in the "obj_disp" field.
#
#     5) Roots are contained in the following areas: the stack, registers
#        specified in the REG mask, and the assignment table.
#

#
# Constants
#

#
# GenGC header offsets from "heap_start"
#

GenGC_HDRSIZE=44				# size of GenGC header
GenGC_HDRL0=0					# pointers to GenGC areas
GenGC_HDRL1=4
GenGC_HDRL2=8
GenGC_HDRL3=12
GenGC_HDRL4=16
GenGC_HDRMAJOR0=20				# history of major collections
GenGC_HDRMAJOR1=24
GenGC_HDRMINOR0=28				# history of minor collections
GenGC_HDRMINOR1=32
GenGC_HDRSTK=36					# start of stack
GenGC_HDRREG=40					# current REG mask

#
# Granularity of heap expansion
#
#   The heap is always expanded in multiples of 2^k, where
#   k is the granularity.
#

GenGC_HEAPEXPGRAN=14				# 2^14=16K

#
# Old to usable heap size ratio
#
#   After a major collection, the ratio of size of old area to the usable
#   size of the heap is at most 1/(2^k) where k is the value provided.
#

GenGC_OLDRATIO=2				# 1/(2^2)=.25=25%

#
# Mask to speficy which registers can be automatically updated
# when a garbage collection occurs.  The Automatic Register Update
# (ARU) mask has a bit set for all possible registers the
# garbage collector is able to handle.  The Register (REG) mask
# determines which register(s) are actually updated.
#
# BITS----------------------------
# 3 2         1         0
# 10987654321098765432109876543210
# --------------------------------
#
# 11000011011111110000000000000000  <-  Auto Register Update (ARU) mask
# +--++--++--++--++--++--++--++--+      $s0-$s6, $t8-$t9, $s8, $ra
#    C   3   7   F   0   0   0   0     ($16-$22, $24-$25, $30, $31)
#

GenGC_ARU_MASK=0xC37F0000

#
# Functions
#

#
# Initialization
#
#   Sets up the header information block for the garbage collector.
#   This block is located at the start of the heap ("heap_start")
#   and includes information needed by the garbage collector.  It
#   also calculates the barrier for the reserve and work areas and
#   sets the L2 pointer accordingly, rounding off in favor of the
#   reserve area.
#
#   INPUT:
#	$a0: start of stack
#	$a1: initial Register mask
#	$a2: end of heap
#	heap_start: start of the heap
#
#   OUTPUT:
#	$gp: lower bound of the work area
#	$s7: upper bound of the work area
#
#   Registers modified:
#	$t0, $t1, $v0, $a0
#

	.globl _GenGC_Init
_GenGC_Init:
	la	$t0 heap_start
	addiu	$t1 $t0 GenGC_HDRSIZE
	sw	$t1 GenGC_HDRL0($t0)		# save start of old area
	sw	$t1 GenGC_HDRL1($t0)		# save start of reserve area
	sub	$t1 $a2 $t1			# find reserve/work area barrier
	srl	$t1 $t1 1
	and	$t1 $t1 -4
	blez	$t1 _GenGC_Init_error		# heap initially to small
	sub	$gp $a2 $t1
	sw	$gp GenGC_HDRL2($t0)		# save start of work area	
	sw	$a2 GenGC_HDRL3($t0)		# save end of work area
	move	$s7 $a2				# set limit pointer
	sw	$0 GenGC_HDRMAJOR0($t0)		# clear histories
	sw	$0 GenGC_HDRMAJOR1($t0)
	sw	$0 GenGC_HDRMINOR0($t0)
	sw	$0 GenGC_HDRMINOR1($t0)
	sw	$a0 GenGC_HDRSTK($t0)		# save stack start
	sw	$a1 GenGC_HDRREG($t0)		# save register mask
	li	$v0 9				# get heap end
	move	$a0 $zero
	syscall					# sbrk
	sw	$v0 GenGC_HDRL4($t0)		# save heap limit
	jr	$ra				# return
_GenGC_Init_error:
	la	$a0 _GenGC_INITERROR		# show error message
	li	$v0 4
	syscall
	li	$v0 10				# exit
	syscall

#
# Record Assignment
#
#   Records an assignment in the assignment table.  Note that because
#   $s7 is always greater than $gp, an assignment can always be
#   recorded.
#
#   INPUT:
#	$a1: pointer to the pointer being modified
#	$s7: limit pointer of the work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $v1, $a0, $a1, $a2, $gp, $s7
#

	.globl _GenGC_Assign
_GenGC_Assign:
	addiu	$s7 $s7 -4
	sw	$a1 0($s7)			# save pointer to assignment
	bgt	$s7 $gp _GenGC_Assign_done
	addiu	$sp $sp -4
	sw	$ra 4($sp)			# save return address
	move	$a1 $0				# size
	addiu	$a0 $sp 4			# end of stack to collect
	jal	_GenGC_Collect
	lw	$ra 4($sp)			# restore return address
	addiu	$sp $sp 4
_GenGC_Assign_done:
	jr	$ra				# return

#
# Record Assignment conditionally, only if GenGC enabled
#
#   Calls GenGC_Assign when GenGC enabled.
#
#   INPUT:
#	$a1: pointer to the pointer being modified
#	$s7: limit pointer of the work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $v1, $a0, $a1, $a2, $gp, $s7
#
	.globl	_MemMgr_Assign
_MemMgr_Assign:
	la	$t0 _MemMgr_COLLECTOR		# pointer to collector function
	lw	$t0 0($t0)
	la	$t1 _GenGC_Collect		
	beq	$t0 $t1 _GenGC_Assign		# tail call to GenGC_Assign
	jr	$ra


	.globl	_gc_check
_gc_check:
	beqz	$a1, _gc_ok			# void is ok
	lw	$a2 obj_eyecatch($a1)		# and check if it is valid
	addiu	$a2 $a2 1
	bnez	$a2 _gc_abort
_gc_ok:
	jr	$ra

_gc_abort:		 
	la      $a0 _gc_abort_msg
	li	$v0 4
	syscall                  # print gc message
	li   	$v0 10
        syscall			 # exit


#
# Generational Garbage Collection
#
#   This function implements the generational garbage collection.
#   It first calls the minor collector, "_GenGC_MinorC", and then
#   updates its history in the header.  The breakpoint is then
#   calculated.  If the breakpoint is reached or there is still not
#   enough room to allocate the requested size, a major garbage
#   collection then takes place by calling "_GenGC_MajorC".  After
#   the major collection, the size of the old area is analyzed.  If
#   it is greater than 1/(2^GenGC_OLDRATIO) of the total usable heap
#   size (L0 to L3), the heap is expanded.  Also, if there is still not
#   enough room to allocate the requested size, the heap is expanded
#   further to make sure that the specified amount of memory can be
#   allocated. If there is enough room in the unused area (L3 to L4),
#   this memory is used and the heap is not expanded.  The $s7 and $gp
#   pointers are then set as well as the L2 pointer.  If a major collection
#   is not done, the X area is incorporated into the old area
#   (i.e. the L2 pointer is moved into L1) and $s7, $gp, and L2 are
#   then set.
#
#   INPUT:
#	$a0: end of stack
#	$a1: size will need to allocate in bytes
#	$s7: limit pointer of thw work area
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   OUTPUT:
#	$a1: size will need to allocate in bytes (unchanged)
#
#   Registers modified:
#	$t0, $t1, $t2, $t3, $t4, $v0, $v1, $a0, $a2, $gp, $s7
#

	.globl _GenGC_Collect
_GenGC_Collect:
	addiu	$sp $sp -12
	sw	$ra 12($sp)			# save return address
	sw	$a0 8($sp)			# save stack end
	sw	$a1 4($sp)			# save size
	la	$a0 _GenGC_COLLECT		# print collection message
	li	$v0 4
	syscall
	lw	$a0 8($sp)			# restore stack end
	jal	_GenGC_MinorC			# minor collection
	la	$a1 heap_start
	lw	$t1 GenGC_HDRMINOR1($a1)
	addu	$t1 $t1 $a0
	srl	$t1 $t1 1
	sw	$t1 GenGC_HDRMINOR1($a1)	# update histories
	sw	$a0 GenGC_HDRMINOR0($a1)
	move	$t0 $t1				# set $t0 to max of minor
	bgt	$t1 $a0 _GenGC_Collect_maxmaj
	move	$t0 $a0
_GenGC_Collect_maxmaj:
	lw	$t1 GenGC_HDRMAJOR0($a1)	# set $t1 to max of major
	lw	$t2 GenGC_HDRMAJOR1($a1)
	bgt	$t1 $t2 _GenGC_Collect_maxdef
	move	$t1 $t2
_GenGC_Collect_maxdef:
	lw	$t2 GenGC_HDRL3($a1)
	sub	$t0 $t2 $t0			# set $t0 to L3-$t0-$t1
	sub	$t0 $t0 $t1
	lw	$t1 GenGC_HDRL0($a1)		# set $t1 to L3-(L3-L0)/2
	sub	$t1 $t2 $t1
	srl	$t1 $t1 1
	sub	$t1 $t2 $t1
	blt	$t0 $t1 _GenGC_Collect_breakpt	# set $t0 to minimum of above
	move	$t0 $t1
_GenGC_Collect_breakpt:
	lw	$t1 GenGC_HDRL1($a1)		# get end of old area
	bge	$t1 $t0 _GenGC_Collect_major
	lw	$t0 GenGC_HDRL2($a1)
	lw	$t1 GenGC_HDRL3($a1)
	lw	$t2 4($sp)			# load requested size into $t2
	sub	$t0 $t1 $t0			# find reserve/work area barrier
	srl	$t0 $t0 1
	and	$t0 $t0 -4
	sub	$t0 $t1 $t0			# reserve/work barrier
	addu	$t2 $t0 $t2			# test allocation
	bge	$t2 $t1 _GenGC_Collect_major	# check if work area too small
_GenGC_Collect_nomajor:
	lw	$t1 GenGC_HDRL2($a1)
	sw	$t1 GenGC_HDRL1($a1)		# expand old area
	sw	$t0 GenGC_HDRL2($a1)		# set new reserve/work barrier
	move	$gp $t0				# set $gp
	lw	$s7 GenGC_HDRL3($a1)		# load limit into $s7
	b	_GenGC_Collect_done
_GenGC_Collect_major:
	la	$a0 _GenGC_Major		# print collection message
	li	$v0 4
	syscall
	lw	$a0 8($sp)			# restore stack end
	jal	_GenGC_MajorC			# major collection
	la	$a1 heap_start
	lw	$t1 GenGC_HDRMAJOR1($a1)
	addu	$t1 $t1 $a0
	srl	$t1 $t1 1
	sw	$t1 GenGC_HDRMAJOR1($a1)	# update histories
	sw	$a0 GenGC_HDRMAJOR0($a1)
	lw	$t1 GenGC_HDRL3($a1)		# find ratio of the old area
	lw	$t0 GenGC_HDRL0($a1)
	sub	$t1 $t1 $t0
	srl	$t1 $t1 GenGC_OLDRATIO
	addu	$t1 $t0 $t1
	lw	$t0 GenGC_HDRL1($a1)
	sub	$t0 $t0 $t1
	sll	$t0 $t0 GenGC_OLDRATIO		# amount to expand in $t0
	lw	$t1 GenGC_HDRL3($a1)		# load L3
	lw	$t2 GenGC_HDRL1($a1)		# load L1
	sub	$t2 $t1 $t2
	srl	$t2 $t2 1
	and	$t2 $t2 -4
	sub	$t1 $t1 $t2			# reserve/work barrier
	lw	$t2 4($sp)			# restore size
	addu	$t1 $t1 $t2
	lw	$t2 GenGC_HDRL3($a1)		# load L3
	sub	$t1 $t1 $t2			# test allocation
	addiu	$t1 $t1 4			# adjust for round off errors
	sll	$t1 $t1 1			# need to allocate $t1 memory
	blt	$t1 $t0 _GenGC_Collect_enough	# put max of $t0, $t1 in $t0
	move	$t0 $t1
_GenGC_Collect_enough:
	blez	$t0 _GenGC_Collect_setL2	# no need to expand
	addiu	$t1 $0 1			# put 1 in $t1
	sll	$t1 $t1 GenGC_HEAPEXPGRAN	# get granularity of expansion
	addiu	$t1 $t1 -1			# align to granularity
	addu	$t0 $t0 $t1
	nor	$t1 $t1 $t1
	and	$t0 $t0 $t1			# total memory needed
	lw	$t1 GenGC_HDRL3($a1)		# load L3
	lw	$t2 GenGC_HDRL4($a1)		# load L4
	sub	$t1 $t2 $t1
	sub	$t2 $t0 $t1			# actual amount to allocate
	bgtz	$t2 _GenGC_Collect_getmem	# check if really need to allocate
_GenGC_Collect_xfermem:
	lw	$s7 GenGC_HDRL3($a1)		# load L3
	addu	$s7 $s7 $t0			# expand by $t0, set $s7
	sw	$s7 GenGC_HDRL3($a1)		# save L3
	b	_GenGC_Collect_findL2
_GenGC_Collect_getmem:
	li	$v0 9				# sbrk
	move	$a0 $t2				# set the size to expand the heap
	syscall
	li	$v0 9
	move	$a0 $zero
	syscall					# get new end of heap in $v0
	sw	$v0 GenGC_HDRL4($a1)		# save L4
	sw	$v0 GenGC_HDRL3($a1)		# save L3
	move	$s7 $v0				# set $s7
	b	_GenGC_Collect_findL2
_GenGC_Collect_setL2:
	lw	$s7 GenGC_HDRL3($a1)		# load L3
_GenGC_Collect_findL2:
	lw	$t1 GenGC_HDRL1($a1)		# load L1
	sub	$t1 $s7 $t1
	srl	$t1 $t1 1
	and	$t1 $t1 -4
	sub	$gp $s7 $t1			# reserve/work barrier
	sw	$gp GenGC_HDRL2($a1)		# save L2
_GenGC_Collect_done:

# Clear new generation to catch missing pointers
	move	$t0 $gp
_GenGC_Clear_loop:
	sw	$zero 0($t0)
	addiu	$t0 $t0 4
	blt	$t0 $s7 _GenGC_Clear_loop

	lw	$a1 4($sp)			# restore size
	lw	$ra 12($sp)			# restore return address
	addiu	$sp $sp 12
	jr	$ra				# return

#
# Check and Copy an Object
#
#   Checks that the input pointer points to an object is a heap
#   object.  If so, it then checks for a forwarding pointer by
#   checking for an object size of 0.  If found, the forwarding
#   pointer is returned.  If not found, the object is copied to $gp
#   and a pointer to it is returned.  The following tests are done to
#   determine if the object is a heap object:
#
#     1) The pointer is within the specified limits
#     2) The pointer is even
#     3) The word before the pointer is the eye catcher 0xFFFF FFFF
#     4) The word at the pointer is a valid tag (i.e. not equal to
#        0xFFFF FFFF)
#
#   INPUT:
#	$a0: pointer to check and copy
#	$a1: lower bound object should be within.
#	$a2: upper bound object should be within.
#	$gp: current allocation pointer
#
#   OUTPUT:
#	$a0: if input points to a heap object then it is set to the
#            new location of object.  If not, it is unchanged.
#	$a1: lower bound object should be within. (unchanged)
#	$a2: upper bound object should be within. (unchanged)
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $a0, $gp
#

	.globl _GenGC_ChkCopy
_GenGC_ChkCopy:
	blt	$a0 $a1 _GenGC_ChkCopy_done	# check bounds
	bge	$a0 $a2 _GenGC_ChkCopy_done
	andi	$t2 $a0 1			# check if odd
	bnez	$t2 _GenGC_ChkCopy_done
	addiu	$t2 $0 -1
	lw	$t1 obj_eyecatch($a0)		# check eyecatcher
	bne	$t2 $t1 _gc_abort
	lw	$t1 obj_tag($a0)		# check object tag
	beq	$t2 $t1 _GenGC_ChkCopy_done
	lw	$t1 obj_size($a0)		# get size of object
	beqz	$t1 _GenGC_ChkCopy_forward	# if size = 0, get forwarding pointer
	move	$t0 $a0				# save pointer to old object in $t0
	addiu	$gp $gp 4			# allocate memory for eyecatcher
	move	$a0 $gp				# get address of new object
	sw	$t2 obj_eyecatch($a0)		# save eye catcher
	sll	$t1 $t1 2			# convert words to bytes
	addu	$t1 $t0 $t1			# set $t1 to limit of copy
	move	$t2 $t0				# set $t2 to old object
_GenGC_ChkCopy_loop:
	lw	$v0 0($t0)			# copy
	sw	$v0 0($gp)
	addiu	$t0 $t0 4			# update each index
	addiu	$gp $gp 4
	bne	$t0 $t1 _GenGC_ChkCopy_loop	# check for limit of copy
	sw	$0 obj_size($t2)		# set size to 0
	sw	$a0 obj_disp($t2)		# save forwarding pointer
_GenGC_ChkCopy_done:
	jr	$ra				# return
_GenGC_ChkCopy_forward:
	lw	$a0 obj_disp($a0)		# get forwarding pointer
	jr	$ra				# return


#
# Minor Garbage Collection
#
#   This garbage collector is run when ever the space in the work
#   area is used up by objects and the assignment table.  The live
#   objects are found and copied to the reserve area.  The L2 pointer
#   is then set to the end of the live objects.  The collector consists
#   of six phases:
#
#     1) Set $gp into the reserve area and set the inputs for ChkCopy
#
#     2) Scan the stack for root pointers into the heap.  The beginning
#        of the stack is in the header and the end is an input to this
#        function.  Look for the appropriate stack flags and act
#        accordingly.  Use "_GenGC_ChkCopy" to validate the pointer and
#        get the new pointer, and then update the stack entry.
#
#     3) Check the registers specified in the Register (REG) mask to
#        automatically update.  This mask is stored in the header.  If
#        bit #n in the mask is set, register #n will be passed to
#        "_GenGC_ChkCopy" and updated with its result.  "_GenGC_SetRegMask"
#        can be used to update this mask.
#
#     4) The assignemnt table is now checked.  $s7 is moved from its
#        current position until it hits the L3 pointer.  Each entry is a
#        pointer to the pointer that must be checked.  Again,
#        "_GenGC_ChkCopy" is used and the pointer updated.
#
#     5) At this point, all root objects are in the reserve area.  This
#        area is now traversed object by object (from L1 to $gp).  It
#        results in a breadth first search of the live objects collected.
#        All attributes of objects are treated as pointers except the
#        "Int", "Bool", and "String" objects.  The first two are skipped
#        completely, and the first attribute of the string object is
#        analyzed (should be a pointer to an "Int" object).
#
#     6) At this point, L2 is set to the end of the live objects in the
#        reserve area.  This is in preparation for a major collection.
#        The size of all the live objects collected is then computed and
#        returned.
#
#   INPUT:
#	$a0: end of stack
#	$s7: limit pointer of this area of storage
#	$gp: current allocation pointer
#	heap_start: start of heap
#
#   OUTPUT:
#	$a0: size of all live objects collected
#
#   Registers modified:
#	$t0, $t1, $t2, $t3, $t4, $v0, $v1, $a0, $a1, $a2, $gp, $s7
#

	.globl _GenGC_MinorC
_GenGC_MinorC:
	addiu	$sp $sp -20
	sw	$ra 20($sp)			# save return address
	la	$t0 heap_start
	lw	$a1 GenGC_HDRL2($t0)		# set lower bound to work area
	move	$a2 $s7				# set upper bound for ChkCopy
	lw	$gp GenGC_HDRL1($t0)		# set $gp into reserve area
	sw	$a0 16($sp)			# save stack end
	lw	$t0 GenGC_HDRSTK($t0)		# set $t0 to stack start
	move	$t1 $a0				# set $t1 to stack end
	ble	$t0 $t1 _GenGC_MinorC_stackend	# check for empty stack
_GenGC_MinorC_stackloop: 			# $t1 stack end, $t0 index
	addiu	$t0 $t0 -4			# update index
	sw	$t0 12($sp)			# save stack index
	lw	$a0 4($t0)			# get stack item
	jal	_GenGC_ChkCopy			# check and copy
	lw	$t0 12($sp)			# load stack index
	sw	$a0 4($t0)
	lw	$t1 16($sp)			# restore stack end
	bgt	$t0 $t1 _GenGC_MinorC_stackloop	# loop
_GenGC_MinorC_stackend:
	la	$t0 heap_start
	lw	$t0 GenGC_HDRREG($t0)		# get Register mask
	sw	$t0 16($sp)			# save Register mask
_GenGC_MinorC_reg16:
	srl	$t0 $t0 16			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg17	# check if set
	move	$a0 $16				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$16 $a0				# update register
_GenGC_MinorC_reg17:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 17			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg18	# check if set
	move	$a0 $17				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$17 $a0				# update register
_GenGC_MinorC_reg18:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 18			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg19	# check if set
	move	$a0 $18				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$18 $a0				# update register
_GenGC_MinorC_reg19:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 19			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg20	# check if set
	move	$a0 $19				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$19 $a0				# update register
_GenGC_MinorC_reg20:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 20			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg21	# check if set
	move	$a0 $20				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$20 $a0				# update register
_GenGC_MinorC_reg21:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 21			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg22	# check if set
	move	$a0 $21				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$21 $a0				# update register
_GenGC_MinorC_reg22:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 22			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg24	# check if set
	move	$a0 $22				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$22 $a0				# update register
_GenGC_MinorC_reg24:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 24			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg25	# check if set
	move	$a0 $24				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$24 $a0				# update register
_GenGC_MinorC_reg25:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 25			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg30	# check if set
	move	$a0 $25				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$25 $a0				# update register
_GenGC_MinorC_reg30:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 30			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_reg31	# check if set
	move	$a0 $30				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$30 $a0				# update register
_GenGC_MinorC_reg31:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 31			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MinorC_regend	# check if set
	move	$a0 $31				# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	move	$31 $a0				# update register
_GenGC_MinorC_regend:
	la	$t0 heap_start
	lw	$t3 GenGC_HDRL0($t0)		# lower limit of old area
	lw	$t4 GenGC_HDRL1($t0)		# upper limit of old area
	lw	$t0 GenGC_HDRL3($t0)		# get L3
	sw	$t0 16($sp)			# save index limit
	bge	$s7 $t0 _GenGC_MinorC_assnend	# check for no assignments
_GenGC_MinorC_assnloop:				# $s7 index, $t0 limit
	lw	$a0 0($s7)			# get table entry
	blt	$a0 $t3 _GenGC_MinorC_assnnext	# must point into old area
	bge	$a0 $t4 _GenGC_MinorC_assnnext
	lw	$a0 0($a0)			# get pointer to check
	jal	_GenGC_ChkCopy			# check and copy
	lw	$t0 0($s7)
	sw	$a0 0($t0)			# update pointer
	lw	$t0 16($sp)			# restore index limit
_GenGC_MinorC_assnnext:
	addiu	$s7 $s7 4			# update index
	blt	$s7 $t0 _GenGC_MinorC_assnloop	# loop
_GenGC_MinorC_assnend:
	la	$t0 heap_start
	lw	$t0 GenGC_HDRL1($t0)		# start of reserve area
	bge	$t0 $gp _GenGC_MinorC_heapend	# check for no objects
_GenGC_MinorC_heaploop:				# $t0: index, $gp: limit
	addiu	$t0 $t0 4			# skip over eyecatcher
	addiu	$t1 $0 -1			# check for eyecatcher
	lw	$t2 obj_eyecatch($t0)
	bne	$t1 $t2 _GenGC_MinorC_error	# eyecatcher not found
	lw	$a0 obj_size($t0)		# get object size
	sll	$a0 $a0 2			# words to bytes
	lw	$t1 obj_tag($t0)		# get the object's tag
	lw	$t2 Int_protObj			# test for int object
	beq	$t1 $t2 _GenGC_MinorC_int
	lw	$t2 Boolean_protObj		# test for bool object
	beq	$t1 $t2 _GenGC_MinorC_bool
	lw	$t2 String_protObj		# test for string object
	beq	$t1 $t2 _GenGC_MinorC_string
_GenGC_MinorC_other:
	addi	$t1 $t0 obj_attr		# start at first attribute
	add	$t2 $t0 $a0			# limit of attributes
	bge	$t1 $t2 _GenGC_MinorC_nextobj	# check for no attributes
	sw	$t0 16($sp)			# save pointer to object
	sw	$a0 12($sp)			# save object size
	sw	$t2 4($sp)			# save limit
_GenGC_MinorC_objloop:				# $t1: index, $t2: limit
	sw	$t1 8($sp)			# save index
	lw	$a0 0($t1)			# set pointer to check
	jal	_GenGC_ChkCopy			# check and copy
	lw	$t1 8($sp)			# restore index
	sw	$a0 0($t1)			# update object pointer
	lw	$t2 4($sp)			# restore limit
	addiu	$t1 $t1 4
	blt	$t1 $t2 _GenGC_MinorC_objloop	# loop
_GenGC_MinorC_objend:
	lw	$t0 16($sp)			# restore pointer to object
	lw	$a0 12($sp)			# restore object size
	b	_GenGC_MinorC_nextobj		# next object
_GenGC_MinorC_string:
	sw	$t0 16($sp)			# save pointer to object
	sw	$a0 12($sp)			# save object size
	lw	$a0 str_size($t0)		# set test pointer
	jal	_GenGC_ChkCopy			# check and copy
	lw	$t0 16($sp)			# restore pointer to object
	sw	$a0 str_size($t0)		# update size pointer
	lw	$a0 12($sp)			# restore object size
_GenGC_MinorC_int:
_GenGC_MinorC_bool:
_GenGC_MinorC_nextobj:
	add	$t0 $t0 $a0			# find next object
	blt	$t0 $gp _GenGC_MinorC_heaploop	# loop
_GenGC_MinorC_heapend:
	la	$t0 heap_start
	sw	$gp GenGC_HDRL2($t0)		# set L2 to $gp
	lw	$a0 GenGC_HDRL1($t0)
	sub	$a0 $gp $a0			# find size after collection
	lw	$ra 20($sp)			# restore return address
	addiu	$sp $sp 20
	jr	$ra				# return
_GenGC_MinorC_error:
	la	$a0 _GenGC_MINORERROR		# show error message
	li	$v0 4
	syscall
	li	$v0 10				# exit
	syscall

#
# Check and Copy an Object with an Offset
#
#   Checks that the input pointer points to an object is a heap object.
#   If so, the pointer is checked to be in one of two areas.  If the
#   pointer is in the X area, L0-L1 is added to the pointer, and the
#   new pointer is returned.  If the pointer points within the old area,
#   it then checks for a forwarding pointer by checking for an object
#   size of 0.  If found, the forwarding pointer is returned.  If not
#   found, the heap is then analyzed to make sure the object can be
#   copied.  It then expands the heap if necessary (updating only $s7),
#   and the copies the object to the $gp pointer.  It takes the new
#   pointer, adds L0-L1 to it, then saves this modified new pointer in
#   the forwarding (obj_disp) field and sets the flag (obj_size to 0).
#   Finally, it returns this pointer.  Note that this pointer does not
#   actually point to the object at this time.  This entire area will
#   later be block copied.  After that, this pointer will be valid.
#   The same tests are done here as in "_GenGC_ChkCopy" to verify that
#   this is a heap object.
#
#   INPUT:
#	$a0: pointer to check and copy with an offset
#	$a1: L0 pointer
#	$a2: L1 pointer
#	$v1: L2 pointer
#	$gp: current allocation pointer
#	$s7: L4 pointer
#
#   OUTPUT:
#	$a0: if input points to a heap object then it is set to the
#            new location of object.  If not, it is unchanged.
#	$a1: L0 pointer (unchanged)
#	$a2: L1 pointer (unchanged)
#	$v1: L2 pointer (unchanged)
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $a0, $gp, $s7
#

	.globl _GenGC_OfsCopy
_GenGC_OfsCopy:
	blt	$a0 $a1 _GenGC_OfsCopy_done	# check lower bound
	bge	$a0 $v1 _GenGC_OfsCopy_done	# check upper bound
	andi	$t2 $a0 1			# check if odd
	bnez	$t2 _GenGC_OfsCopy_done
	addiu	$t2 $0 -1
	lw	$t1 obj_eyecatch($a0)		# check eyecatcher
	bne	$t2 $t1 _gc_abort
	lw	$t1 obj_tag($a0)		# check object tag
	beq	$t2 $t1 _GenGC_OfsCopy_done
	blt	$a0 $a2 _GenGC_OfsCopy_old	# check if old, X object
	sub	$v0 $a1 $a2			# compute offset
	add	$a0 $a0 $v0			# apply pointer offset
	jr	$ra				# return
_GenGC_OfsCopy_old:
	lw	$t1 obj_size($a0)		# get size of object
	sll	$t1 $t1 2			# convert words to bytes
	beqz	$t1 _GenGC_OfsCopy_forward	# if size = 0, get forwarding pointer
	move	$t0 $a0				# save pointer to old object in $t0
	addu	$v0 $gp $t1			# test allocation
	addiu	$v0 $v0 4
	blt	$v0 $s7 _GenGC_OfsCopy_memok	# check if enoguh room for object
	sub	$a0 $v0 $s7			# amount to expand minus 1
	addiu	$v0 $0 1
	sll	$v0 $v0 GenGC_HEAPEXPGRAN
	add	$a0 $a0 $v0
	addiu	$v0 $v0 -1
	nor	$v0 $v0 $v0			# get grain mask
	and	$a0 $a0 $v0			# align to grain size
	li	$v0 9
	syscall					# expand heap
	li	$v0 9
	move	$a0 $0
	syscall					# get end of heap in $v0
	move	$s7 $v0				# save heap end in $s7
	move	$a0 $t0				# restore pointer to old object in $a0
_GenGC_OfsCopy_memok:
	addiu	$gp $gp 4			# allocate memory for eyecatcher
	move	$a0 $gp				# get address of new object
	sw	$t2 obj_eyecatch($a0)		# save eye catcher
	addu	$t1 $t0 $t1			# set $t1 to limit of copy
	move	$t2 $t0				# set $t2 to old object
_GenGC_OfsCopy_loop:
	lw	$v0 0($t0)			# copy
	sw	$v0 0($gp)
	addiu	$t0 $t0 4			# update each index
	addiu	$gp $gp 4
	bne	$t0 $t1 _GenGC_OfsCopy_loop	# check for limit of copy
	sw	$0 obj_size($t2)		# set size to 0
	sub	$v0 $a1 $a2			# compute offset
	add	$a0 $a0 $v0			# apply pointer offset
	sw	$a0 obj_disp($t2)		# save forwarding pointer
_GenGC_OfsCopy_done:
	jr	$ra				# return
_GenGC_OfsCopy_forward:
	lw	$a0 obj_disp($a0)		# get forwarding pointer
	jr	$ra				# return

#
# Major Garbage Collection
#
#   This collection occurs when ever the old area grows beyond a specified
#   point.  The minor collector sets up the Old, X, and New areas for
#   this collector.  It then collects all the live objects in the old
#   area (L0 to L1) into the new area (L2 to L3).  This collection consists
#   of five phases:
#
#     1) Set $gp into the new area (L2), and $s7 to L4.  Also set the
#        inputs for "_GenGC_OfsCopy".
#
#     2) Traverse the stack (see the minor collector) using "_GenGC_OfsCopy".
#
#     3) Check the registers (see the minor collector) using "_GenGC_OfsCopy".
#
#     4) Traverse the heap from L1 to $gp using "_GenGC_OfsCopy".  Note
#        that this includes the X area.  (see the minor collector)
#
#     5) Block copy the region L1 to $gp back L1-L0 bytes to create the
#        next old area.  Save the end in L1.  Calculate the size of the
#        live objects collected from the old area and return this value.
#
#   Note that the pointers returned by "_GenGC_OfsCopy" are not valid
#   until the block copy is done.
#
#   INPUT:
#	$a0: end of stack
#	heap_start: start of heap
#
#   OUTPUT:
#	$a0: size of all live objects collected
#
#   Registers modified:
#	$t0, $t1, $t2, $v0, $v1, $a0, $a1, $a2, $gp, $s7
#

	.globl _GenGC_MajorC
_GenGC_MajorC:
	addiu	$sp $sp -20
	sw	$ra 20($sp)			# save return address
	la	$t0 heap_start
	lw	$s7 GenGC_HDRL4($t0)		# limit pointer for collection
	lw	$gp GenGC_HDRL2($t0)		# allocation pointer for collection
	lw	$a1 GenGC_HDRL0($t0)		# set inputs for OfsCopy
	lw	$a2 GenGC_HDRL1($t0)
	lw	$v1 GenGC_HDRL2($t0)
	sw	$a0 16($sp)			# save stack end
	lw	$t0 GenGC_HDRSTK($t0)		# set $t0 to stack start
	move	$t1 $a0				# set $t1 to stack end
	ble	$t0 $t1 _GenGC_MajorC_stackend	# check for empty stack
_GenGC_MajorC_stackloop: 			# $t1 stack end, $t0 index
	addiu	$t0 $t0 -4			# update index
	sw	$t0 12($sp)			# save stack index
	lw	$a0 4($t0)			# get stack item
	jal	_GenGC_OfsCopy			# check and copy
	lw	$t0 12($sp)			# load stack index
	sw	$a0 4($t0)
	lw	$t1 16($sp)			# restore stack end
	bgt	$t0 $t1 _GenGC_MajorC_stackloop	# loop
_GenGC_MajorC_stackend:
	la	$t0 heap_start
	lw	$t0 GenGC_HDRREG($t0)		# get Register mask
	sw	$t0 16($sp)			# save Register mask
_GenGC_MajorC_reg16:
	srl	$t0 $t0 16			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg17	# check if set
	move	$a0 $16				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$16 $a0				# update register
_GenGC_MajorC_reg17:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 17			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg18	# check if set
	move	$a0 $17				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$17 $a0				# update register
_GenGC_MajorC_reg18:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 18			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg19	# check if set
	move	$a0 $18				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$18 $a0				# update register
_GenGC_MajorC_reg19:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 19			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg20	# check if set
	move	$a0 $19				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$19 $a0				# update register
_GenGC_MajorC_reg20:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 20			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg21	# check if set
	move	$a0 $20				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$20 $a0				# update register
_GenGC_MajorC_reg21:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 21			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg22	# check if set
	move	$a0 $21				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$21 $a0				# update register
_GenGC_MajorC_reg22:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 22			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg24	# check if set
	move	$a0 $22				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$22 $a0				# update register
_GenGC_MajorC_reg24:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 24			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg25	# check if set
	move	$a0 $24				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$24 $a0				# update register
_GenGC_MajorC_reg25:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 25			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg30	# check if set
	move	$a0 $25				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$25 $a0				# update register
_GenGC_MajorC_reg30:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 30			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_reg31	# check if set
	move	$a0 $30				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$30 $a0				# update register
_GenGC_MajorC_reg31:
	lw	$t0 16($sp)			# restore mask
	srl	$t0 $t0 31			# shift to proper bit
	andi	$t1 $t0 1
	beq	$t1 $0 _GenGC_MajorC_regend	# check if set
	move	$a0 $31				# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	move	$31 $a0				# update register
_GenGC_MajorC_regend:
	la	$t0 heap_start
	lw	$t0 GenGC_HDRL1($t0)		# start of X area
	bge	$t0 $gp _GenGC_MajorC_heapend	# check for no objects
_GenGC_MajorC_heaploop:				# $t0: index, $gp: limit
	addiu	$t0 $t0 4			# skip over eyecatcher
	addiu	$t1 $0 -1			# check for eyecatcher
	lw	$t2 obj_eyecatch($t0)
	bne	$t1 $t2 _GenGC_MajorC_error	# eyecatcher not found
	lw	$a0 obj_size($t0)		# get object size
	sll	$a0 $a0 2			# words to bytes
	lw	$t1 obj_tag($t0)		# get the object's tag
	lw	$t2 Int_protObj			# test for int object
	beq	$t1 $t2 _GenGC_MajorC_int
	lw	$t2 Boolean_protObj		# test for bool object
	beq	$t1 $t2 _GenGC_MajorC_bool
	lw	$t2 String_protObj		# test for string object
	beq	$t1 $t2 _GenGC_MajorC_string
_GenGC_MajorC_other:
	addi	$t1 $t0 obj_attr		# start at first attribute
	add	$t2 $t0 $a0			# limit of attributes
	bge	$t1 $t2 _GenGC_MajorC_nextobj	# check for no attributes
	sw	$t0 16($sp)			# save pointer to object
	sw	$a0 12($sp)			# save object size
	sw	$t2 4($sp)			# save limit
_GenGC_MajorC_objloop:				# $t1: index, $t2: limit
	sw	$t1 8($sp)			# save index
	lw	$a0 0($t1)			# set pointer to check
	jal	_GenGC_OfsCopy			# check and copy
	lw	$t1 8($sp)			# restore index
	sw	$a0 0($t1)			# update object pointer
	lw	$t2 4($sp)			# restore limit
	addiu	$t1 $t1 4
	blt	$t1 $t2 _GenGC_MajorC_objloop	# loop
_GenGC_MajorC_objend:
	lw	$t0 16($sp)			# restore pointer to object
	lw	$a0 12($sp)			# restore object size
	b	_GenGC_MajorC_nextobj		# next object
_GenGC_MajorC_string:
	sw	$t0 16($sp)			# save pointer to object
	sw	$a0 12($sp)			# save object size
	lw	$a0 str_size($t0)		# set test pointer
	jal	_GenGC_OfsCopy			# check and copy
	lw	$t0 16($sp)			# restore pointer to object
	sw	$a0 str_size($t0)		# update size pointer
	lw	$a0 12($sp)			# restore object size
_GenGC_MajorC_int:
_GenGC_MajorC_bool:
_GenGC_MajorC_nextobj:
	add	$t0 $t0 $a0			# find next object
	blt	$t0 $gp _GenGC_MajorC_heaploop	# loop
_GenGC_MajorC_heapend:
	la	$t0 heap_start
	lw	$a0 GenGC_HDRL2($t0)		# get end of collection
	sub	$a0 $gp $a0			# get length after collection
	lw	$t1 GenGC_HDRL0($t0)		# get L0
	lw	$t2 GenGC_HDRL1($t0)		# get L1
	bge	$t2 $gp _GenGC_MajorC_bcpyend	# test for empty copy
_GenGC_MajorC_bcpyloop:				# $t2 index, $gp limit, $t1 dest
	lw	$v0 0($t2)			# copy
	sw	$v0 0($t1)
	addiu	$t2 $t2 4			# update each index
	addiu	$t1 $t1 4
	bne	$t2 $gp _GenGC_MajorC_bcpyloop	# loop
_GenGC_MajorC_bcpyend:
	sw	$s7 GenGC_HDRL4($t0)		# save end of heap
	lw	$t1 GenGC_HDRL0($t0)		# get L0
	lw	$t2 GenGC_HDRL1($t0)		# get L1
	sub	$t1 $t2 $t1			# find offset of block copy
	sub	$gp $gp $t1			# find end of old area
	sw	$gp GenGC_HDRL1($t0)		# save end of old area
	lw	$ra 20($sp)			# restore return address
	addiu	$sp $sp 20
	jr	$ra				# return
_GenGC_MajorC_error:
	la	$a0 _GenGC_MAJORERROR		# show error message
	li	$v0 4
	syscall
	li	$v0 10				# exit
	syscall

#
# Set the Register (REG) mask
#
#   If bit #n is set in the Register mask, register #n will be
#   automatically updated by the garbage collector.  Note that
#   this mask is masked (ANDed) with the ARU mask.  Only those
#   registers in the ARU mask can be updated automatically.
#
#   INPUT:
#	$a0: new Register (REG) mask
#	heap_start: start of the heap
#
#   Registers modified:
#	$t0
#

	.globl	_GenGC_SetRegMask
_GenGC_SetRegMask:
	li	$t0 GenGC_ARU_MASK		# apply Automatic Register Mask (ARU)
	and	$a0 $a0 $t0
	la	$t0 heap_start			# set $t0 to the start of the heap
	sw	$a0 GenGC_HDRREG($t0)		# save the Register mask
	jr	$ra				# return

#
# Query the Register (REG) mask
#
#   INPUT:
#	heap_start: start of the heap
#
#   OUTPUT:
#	$a0: current Register (REG) mask
#
#   Registers modified:
#	none
#

	.globl	_GenGC_QRegMask
_GenGC_QRegMask:
	la	$a0 heap_start			# set $a0 to the start of the heap
	lw	$a0 GenGC_HDRREG($a0)		# get the Register mask
	jr	$ra				# return


#
# NoGC Garbage Collector
#
#   NoGC does not attempt to do any garbage collection.
#   It simply expands the heap if more memory is needed.
#

#
# Some constants
#

NoGC_EXPANDSIZE=0x10000				# size to expand heap

#
# Initialization
#
#   INPUT:
#	none
#
#   OUTPUT:
#	$gp: lower bound of the work area
#	$s7: upper bound of the work area
#
#   Registers modified:
#	$a0, $v0
#
	.globl _NoGC_Init
_NoGC_Init:
	la	$gp heap_start			# set $gp to the start of the heap
	li	$v0 9				# get heap end
	move	$a0 $zero
	syscall					# sbrk
	move	$s7 $v0				# set limit pointer
	jr	$ra

#
# Collection
#
#   Expand the heap as necessary.
#
#   INPUT:
#	$a1: size will need to allocate in bytes
#	$s7: limit pointer of thw work area
#	$gp: current allocation pointer
#
#   OUTPUT:
#	$a1: size will need to allocate in bytes (unchanged)
#
#   Registers modified:
#	$t0, $a0, $v0, $gp, $s7
#

	.globl _NoGC_Collect
_NoGC_Collect:
	la	$a0 _NoGC_COLLECT		# show collection message
	li	$v0 4
	syscall
_NoGC_Collect_loop:
	add	$t0 $gp $a1			# test allocation
	blt	$t0 $s7 _NoGC_Collect_ok	# stop if enough
	li	$v0 9				# expand heap
	li	$a0 NoGC_EXPANDSIZE		# set the size to expand the heap
	syscall					# sbrk
	li	$v0 9				# get heap end
	move	$a0 $zero
	syscall					# sbrk
	move	$s7 $v0				# set limit pointer
	b	_NoGC_Collect_loop		# loop
_NoGC_Collect_ok:
	jr	$ra				# return



#
#
# ArrayAny.ArrayAny and ArrayAny.resize
#		Returns Int Obj with array length of self
#
#	INPUT:	$a0 the array object, 20($sp) new size of the array
#	OUTPUT:	$a0 the new array 
#
#
	.globl	ArrayAny.resize
	.globl	ArrayAny.ArrayAny
ArrayAny.resize:
ArrayAny.ArrayAny:
	addiu	$sp $sp -16
	sw	$ra 16($sp)			# save return address
	sw	$a0 12($sp)			# save self arg.
	sw	$0 8($sp)			# init GC area
	sw	$0 4($sp)			# init GC area

	jal	_MemMgr_Test			# test GC area

	lw	$t1 20($sp)			# load arg object
	lw	$t1 int_slot($t1)		# arg new array size
	bltz	$t1 _ar_abort2			# check if resize is negative
	lw      $t0 ary_size($a0)		# size of array of Int
	lw	$t0 int_slot($t0)		# as int

	sll     $t1 $t1 2			# multiply by 4

	addiu	$a0 $t1 ary_field		# size to allocat
	addiu   $a0 $a0 4                       # account for eyecatcher
	jal	_MemMgr_Alloc			# allocate memory -> $a0
	addiu	$a1 $a0 4			# pointer to object -> $a1

	addiu	$t1 $0 -1
	sw	$t1 obj_eyecatch($a1)		# store eyecatcher

	lw	$a0 12($sp)			# get self -> $a0
	lw	$t0 ary_size($a0)		# original size : Int
	lw	$t0 int_slot($t0)		# original size : int
	lw	$t1 20($sp)			# new size : Int
	lw	$t1 int_slot($t1)		# new size : int
	move	$t2 $t0				# min size
	bgt	$t1 $t0 _array_copy_setup
	move	$t2 $t1				# array is getting smaller
_array_copy_setup:
	sll     $t2 $t2 2			# multiply by 4
	addiu	$t2 $t2 ary_field		# space for header
	add	$a2 $t2 $a0			# find limit of copy
	move	$v1 $a1				# save source
_array_copy_loop:
	lw	$v0 0($a0)			# get word from self
	sw	$v0 0($v1)			# store in new array
	addiu	$a0 $a0 4			# update source
	addiu	$v1 $v1 4			# update destination
	bne	$a0 $a2	_array_copy_loop	# loop
_array_copy_end:
	lw	$v0 20($sp)			# get new size
	sw	$v0 ary_size($a1)		# save in new array
	addiu	$v0 $t1 ary_header_words	# add header size
	sw	$v0 obj_size($a1)		# save in new array
	ble	$t1 $t0 _array_copy_return	# if new copy not bigger, done
_array_init_setup:
	sll	$t1 $t1 2			# multiply by 4
	addiu	$t1 $t1 ary_field		# space for header
	add	$a2 $t1 $a1			# find limit of init
_array_init_loop:
	sw	$0 0($v1)			# init new array
	addiu	$v1 $v1 4			# update destination
	bne	$v1 $a2	_array_init_loop	# loop
_array_init_end:
_array_copy_return:
	move	$a0 $a1				# return new array
	lw	$ra 16($sp)			# restore return address
	addiu	$sp $sp 20			# pop argument
	jr	$ra				# return

_ar_abort1:
	la	$a0 _aabort_msg3
	b	_ar_abort
_ar_abort2:
	la	$a0 _aabort_msg4
_ar_abort:
	li	$v0 4
	syscall
	la	$a0 _aabort_msg
	li	$v0 4
	syscall
	li	$v0 10				#exit
	syscall




#
#
# ArrayAny.get
#               Returns an Object within the array
#
#       INPUT:  $a0 the array object, 12($sp) index into the array
#       OUTPUT: the object from the array
#
#
	.globl ArrayAny.get
ArrayAny.get:
	addiu 	$sp $sp -8			
	sw 	$ra 8($sp)			# save return address
	sw	$a0 4($sp)			# save self pointer
	
	lw	$t1 12($sp)			# load arg object 
	lw	$t1 int_slot($t1)		# get the value of the index
	bltz	$t1 _ag_abort1			# about if less then zero
	lw	$t0 4($sp)			# load self object 
	lw	$t0 ary_size($t0)		# get size of array object 
	lw	$t0 int_slot($t0)		# get array size
	sub	$t2 $t0 $t1			# subtract index from array size
	blez	$t2 _ag_abort2			# branch if less then or equal zero

	sll	$t1 $t1	2			# multiply index by 4
		
	lw	$a0 4($sp)			# load self object 
	addiu	$a0 $a0	ary_field		# add ary_field
	addu	$a0 $a0 $t1			# find the pointer
	lw	$a0 0($a0)			# load the object pointer 

	lw	$ra 8($sp)			# restore return address
	addiu	$sp $sp 12			# pop argument
	jr	$ra				# return
	
_ag_abort1:
	la	$a0 _aabort_msg1
	b	_ag_abort
_ag_abort2:
	la	$a0 _aabort_msg2
_ag_abort:
	li	$v0 4
	syscall
	la	$a0 _aabort_msg
	li	$v0 4
	syscall
	li	$v0 10				#exit
	syscall


#
#
# ArrayAny.set
#               Sets an item within the array 
#
#       INPUT:  $a0 the array object, 16($sp) index into the array
#		12($sp) object to be stored in the array
#       OUTPUT: $a0 the former array element
#
#
	.globl ArrayAny.set
ArrayAny.set:
	addiu 	$sp $sp -8
	sw 	$ra 8($sp)			# save return address
	sw	$a0 4($sp)			# save self pointer
	
	lw	$t1 16($sp)			# load arg object
	lw	$t1 int_slot($t1)		# get the value of the index
	bltz	$t1 _as_abort1			# if less then zero abort
	lw	$t0 4($sp)			# load self pointer
	lw	$t0 ary_size($t0)		# get size of array object
	lw	$t0 int_slot($t0)		# get the size
	sub	$t0 $t0 $t1			# subtract size of array from index
	blez	$t0 _as_abort2			# branch if less then or equal zero

	sll	$t1 $t1 2			# multiply index by 4

	lw	$a0 4($sp)			# load self object	
	addiu	$a1 $a0	ary_field		# move to the start of array data
	addu	$a1 $a1 $t1			# move to the index position

	lw	$t0 12($sp)			# load the object to be stored
	lw	$t1 0($a1)			# get old value
	sw	$t0 0($a1)			# store in array
	sw	$t1 4($sp)			# overwrite in frame
	jal	_MemMgr_Assign			# check assignment

	lw	$a0 4($sp)			# get result value
	lw	$ra 8($sp)			# restore return address
	addiu	$sp $sp 16			# pop argument
	jr	$ra				# return
_as_abort1:
	la	$a0 _aabort_msg1
	b	_as_abort
_as_abort2:
	la	$a0 _aabort_msg2
_as_abort:
	li	$v0 4
	syscall
	la	$a0 _aabort_msg
	li	$v0 4
	syscall
	li	$v0 10				#exit
	syscall
